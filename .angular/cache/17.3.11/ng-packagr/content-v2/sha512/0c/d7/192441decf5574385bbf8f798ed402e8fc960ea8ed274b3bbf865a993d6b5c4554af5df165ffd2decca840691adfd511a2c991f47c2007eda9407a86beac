{"hash":"1a0d292ab8ee31bf2d29a579005bf672efddd178","fesm2022":[{"exports":["KEYS","LoadingComponent","TREE_ACTIONS","TreeAnimateOpenDirective","TreeComponent","TreeDragDirective","TreeDraggedElement","TreeDropDirective","TreeMobxAutorunDirective","TreeModel","TreeModule","TreeNode","TreeNodeCheckboxComponent","TreeNodeChildrenComponent","TreeNodeCollectionComponent","TreeNodeComponent","TreeNodeContent","TreeNodeDropSlot","TreeNodeExpanderComponent","TreeNodeWrapperComponent","TreeViewportComponent","TreeVirtualScroll"],"facadeModuleId":"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/circlon-angular-tree-component.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/mobx-angular/tree-mobx-autorun.directive.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/constants/keys.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-options.model.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/constants/events.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-node.model.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree.model.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-dragged-element.model.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-virtual-scroll.model.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/loading.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-viewport.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/directives/tree-drop.directive.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-drop-slot.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/mobx-angular/mobx-proxy.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-collection.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/directives/tree-animate-open.directive.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-children.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-content.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/directives/tree-drag.directive.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-expander.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-checkbox.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-wrapper.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node.component.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/angular-tree-component.module.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/public-api.mjs","/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/circlon-angular-tree-component.mjs"],"name":"circlon-angular-tree-component","type":"chunk","dynamicImports":[],"fileName":"circlon-angular-tree-component.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["*","Directive","Input","Injectable","Component","ViewEncapsulation","EventEmitter","Output","HostListener","ContentChild","ViewChild","NgModule"],"@angular/common":["*","CommonModule"],"mobx":["autorun","reaction","computed","observable","action"]},"imports":["@angular/core","@angular/common","mobx"],"modules":{"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/mobx-angular/tree-mobx-autorun.directive.mjs":{"code":"class TreeMobxAutorunDirective {\n    templateRef;\n    viewContainer;\n    templateBindings = {};\n    dispose;\n    view;\n    treeMobxAutorun;\n    constructor(templateRef, viewContainer) {\n        this.templateRef = templateRef;\n        this.viewContainer = viewContainer;\n    }\n    ngOnInit() {\n        this.view = this.viewContainer.createEmbeddedView(this.templateRef);\n        if (this.dispose) {\n            this.dispose();\n        }\n        if (this.shouldDetach()) {\n            this.view.detach();\n        }\n        this.autoDetect(this.view);\n    }\n    shouldDetach() {\n        return this.treeMobxAutorun && this.treeMobxAutorun.detach;\n    }\n    autoDetect(view) {\n        this.dispose = autorun(() => view.detectChanges());\n    }\n    ngOnDestroy() {\n        if (this.dispose) {\n            this.dispose();\n        }\n    }\n    /** @nocollapse */ static ɵfac = function TreeMobxAutorunDirective_Factory(t) { return new (t || TreeMobxAutorunDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeMobxAutorunDirective, selectors: [[\"\", \"treeMobxAutorun\", \"\"]], inputs: { treeMobxAutorun: \"treeMobxAutorun\" } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeMobxAutorunDirective, [{\n        type: Directive,\n        args: [{ selector: '[treeMobxAutorun]' }]\n    }], () => [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }], { treeMobxAutorun: [{\n            type: Input\n        }] }); })();","originalLength":4888,"removedExports":[],"renderedExports":["TreeMobxAutorunDirective"],"renderedLength":1580},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/constants/keys.mjs":{"code":"const KEYS = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    ENTER: 13,\n    SPACE: 32,\n    CONTEXT_MENU: 32\n};","originalLength":833,"removedExports":[],"renderedExports":["KEYS"],"renderedLength":123},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-options.model.mjs":{"code":"const TREE_ACTIONS = {\n    TOGGLE_ACTIVE: (tree, node, $event) => node && node.toggleActivated(),\n    TOGGLE_ACTIVE_MULTI: (tree, node, $event) => node && node.toggleActivated(true),\n    TOGGLE_SELECTED: (tree, node, $event) => node && node.toggleSelected(),\n    ACTIVATE: (tree, node, $event) => node.setIsActive(true),\n    DEACTIVATE: (tree, node, $event) => node.setIsActive(false),\n    SELECT: (tree, node, $event) => node.setIsSelected(true),\n    DESELECT: (tree, node, $event) => node.setIsSelected(false),\n    FOCUS: (tree, node, $event) => node.focus(),\n    TOGGLE_EXPANDED: (tree, node, $event) => node.hasChildren && node.toggleExpanded(),\n    EXPAND: (tree, node, $event) => node.expand(),\n    COLLAPSE: (tree, node, $event) => node.collapse(),\n    DRILL_DOWN: (tree, node, $event) => tree.focusDrillDown(),\n    DRILL_UP: (tree, node, $event) => tree.focusDrillUp(),\n    NEXT_NODE: (tree, node, $event) => tree.focusNextNode(),\n    PREVIOUS_NODE: (tree, node, $event) => tree.focusPreviousNode(),\n    MOVE_NODE: (tree, node, $event, { from, to }) => {\n        // default action assumes from = node, to = {parent, index}\n        if ($event.ctrlKey) {\n            tree.copyNode(from, to);\n        }\n        else {\n            tree.moveNode(from, to);\n        }\n    }\n};\nconst defaultActionMapping = {\n    mouse: {\n        click: TREE_ACTIONS.TOGGLE_ACTIVE,\n        dblClick: null,\n        contextMenu: null,\n        expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,\n        checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,\n        drop: TREE_ACTIONS.MOVE_NODE\n    },\n    keys: {\n        [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\n        [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\n        [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\n        [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\n        [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\n        [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\n    }\n};\nclass TreeOptions {\n    options;\n    get hasChildrenField() { return this.options.hasChildrenField || 'hasChildren'; }\n    get childrenField() { return this.options.childrenField || 'children'; }\n    get displayField() { return this.options.displayField || 'name'; }\n    get idField() { return this.options.idField || 'id'; }\n    get isExpandedField() { return this.options.isExpandedField || 'isExpanded'; }\n    get getChildren() { return this.options.getChildren; }\n    get levelPadding() { return this.options.levelPadding || 0; }\n    get useVirtualScroll() { return this.options.useVirtualScroll; }\n    get animateExpand() { return this.options.animateExpand; }\n    get animateSpeed() { return this.options.animateSpeed || 1; }\n    get animateAcceleration() { return this.options.animateAcceleration || 1.2; }\n    get scrollOnActivate() { return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate; }\n    get rtl() { return !!this.options.rtl; }\n    get rootId() { return this.options.rootId; }\n    get useCheckbox() { return this.options.useCheckbox; }\n    get useTriState() { return this.options.useTriState === undefined ? true : this.options.useTriState; }\n    get scrollContainer() { return this.options.scrollContainer; }\n    get allowDragoverStyling() { return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling; }\n    actionMapping;\n    constructor(options = {}) {\n        this.options = options;\n        this.actionMapping = {\n            mouse: {\n                click: this.options?.actionMapping?.mouse?.click ?? defaultActionMapping.mouse.click,\n                dblClick: this.options?.actionMapping?.mouse?.dblClick ?? defaultActionMapping.mouse.dblClick,\n                contextMenu: this.options?.actionMapping?.mouse?.contextMenu ?? defaultActionMapping.mouse.contextMenu,\n                expanderClick: this.options?.actionMapping?.mouse?.expanderClick ?? defaultActionMapping.mouse.expanderClick,\n                checkboxClick: this.options?.actionMapping?.mouse?.checkboxClick ?? defaultActionMapping.mouse.checkboxClick,\n                drop: this.options?.actionMapping?.mouse?.drop ?? defaultActionMapping.mouse.drop,\n                dragStart: this.options?.actionMapping?.mouse?.dragStart ?? undefined,\n                drag: this.options?.actionMapping?.mouse?.drag ?? undefined,\n                dragEnd: this.options?.actionMapping?.mouse?.dragEnd ?? undefined,\n                dragOver: this.options?.actionMapping?.mouse?.dragOver ?? undefined,\n                dragLeave: this.options?.actionMapping?.mouse?.dragLeave ?? undefined,\n                dragEnter: this.options?.actionMapping?.mouse?.dragEnter ?? undefined,\n                mouseOver: this.options?.actionMapping?.mouse?.mouseOver ?? undefined,\n                mouseOut: this.options?.actionMapping?.mouse?.mouseOut ?? undefined,\n            },\n            keys: {\n                [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\n                [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\n                [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\n                [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\n                [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\n                [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\n            }\n        };\n        if (this.options?.actionMapping?.keys) {\n            this.actionMapping.keys = {\n                ...this.actionMapping.keys,\n                ...this.options.actionMapping.keys\n            };\n        }\n        if (options.rtl) {\n            this.actionMapping.keys[KEYS.RIGHT] = options.actionMapping?.keys[KEYS.RIGHT] || TREE_ACTIONS.DRILL_UP;\n            this.actionMapping.keys[KEYS.LEFT] = options.actionMapping?.keys[KEYS.LEFT] || TREE_ACTIONS.DRILL_DOWN;\n        }\n    }\n    getNodeClone(node) {\n        if (this.options.getNodeClone) {\n            return this.options.getNodeClone(node);\n        }\n        // remove id from clone\n        // keeping ie11 compatibility\n        const nodeClone = Object.assign({}, node.data);\n        if (nodeClone.id) {\n            delete nodeClone.id;\n        }\n        return nodeClone;\n    }\n    allowDrop(element, to, $event) {\n        if (this.options.allowDrop instanceof Function) {\n            return this.options.allowDrop(element, to, $event);\n        }\n        else {\n            return this.options.allowDrop === undefined ? true : this.options.allowDrop;\n        }\n    }\n    allowDrag(node) {\n        if (this.options.allowDrag instanceof Function) {\n            return this.options.allowDrag(node);\n        }\n        else {\n            return this.options.allowDrag;\n        }\n    }\n    nodeClass(node) {\n        return this.options.nodeClass ? this.options.nodeClass(node) : '';\n    }\n    nodeHeight(node) {\n        if (node.data.virtual) {\n            return 0;\n        }\n        let nodeHeight = this.options.nodeHeight || 22;\n        if (typeof nodeHeight === 'function') {\n            nodeHeight = nodeHeight(node);\n        }\n        // account for drop slots:\n        return nodeHeight + (node.index === 0 ? 2 : 1) * this.dropSlotHeight;\n    }\n    get dropSlotHeight() {\n        return typeof this.options.dropSlotHeight === 'number' ? this.options.dropSlotHeight : 2;\n    }\n}","originalLength":28267,"removedExports":[],"renderedExports":["TREE_ACTIONS","TreeOptions"],"renderedLength":7096},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/constants/events.mjs":{"code":"const TREE_EVENTS = {\n    toggleExpanded: 'toggleExpanded',\n    activate: 'activate',\n    deactivate: 'deactivate',\n    nodeActivate: 'nodeActivate',\n    nodeDeactivate: 'nodeDeactivate',\n    select: 'select',\n    deselect: 'deselect',\n    focus: 'focus',\n    blur: 'blur',\n    initialized: 'initialized',\n    updateData: 'updateData',\n    moveNode: 'moveNode',\n    copyNode: 'copyNode',\n    event: 'event',\n    loadNodeChildren: 'loadNodeChildren',\n    changeFilter: 'changeFilter',\n    stateChange: 'stateChange'\n};","originalLength":2039,"removedExports":[],"renderedExports":["TREE_EVENTS"],"renderedLength":517},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-node.model.mjs":{"code":"var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$3 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nclass TreeNode {\n    data;\n    parent;\n    treeModel;\n    handler;\n    get isHidden() { return this.treeModel.isHidden(this); }\n    ;\n    get isExpanded() { return this.treeModel.isExpanded(this); }\n    ;\n    get isActive() { return this.treeModel.isActive(this); }\n    ;\n    get isFocused() { return this.treeModel.isNodeFocused(this); }\n    ;\n    get isSelected() {\n        if (this.isSelectable()) {\n            return this.treeModel.isSelected(this);\n        }\n        else {\n            return this.children.some((node) => node.isSelected);\n        }\n    }\n    ;\n    get isAllSelected() {\n        if (this.isSelectable()) {\n            return this.treeModel.isSelected(this);\n        }\n        else {\n            return this.children.every((node) => node.isAllSelected);\n        }\n    }\n    ;\n    get isPartiallySelected() {\n        return this.isSelected && !this.isAllSelected;\n    }\n    children;\n    index;\n    position = 0;\n    height;\n    get level() {\n        return this.parent ? this.parent.level + 1 : 0;\n    }\n    get path() {\n        return this.parent ? [...this.parent.path, this.id] : [];\n    }\n    get elementRef() {\n        throw `Element Ref is no longer supported since introducing virtual scroll\\n\n      You may use a template to obtain a reference to the element`;\n    }\n    _originalNode;\n    get originalNode() { return this._originalNode; }\n    ;\n    constructor(data, parent, treeModel, index) {\n        this.data = data;\n        this.parent = parent;\n        this.treeModel = treeModel;\n        if (this.id === undefined || this.id === null) {\n            this.id = uuid();\n        } // Make sure there's a unique id without overriding existing ids to work with immutable data structures\n        this.index = index;\n        if (this.getField('children')) {\n            this._initChildren();\n        }\n        this.autoLoadChildren();\n    }\n    // helper get functions:\n    get hasChildren() {\n        return !!(this.getField('hasChildren') || (this.children && this.children.length > 0));\n    }\n    get isCollapsed() { return !this.isExpanded; }\n    get isLeaf() { return !this.hasChildren; }\n    get isRoot() { return this.parent.data.virtual; }\n    get realParent() { return this.isRoot ? null : this.parent; }\n    // proxy functions:\n    get options() { return this.treeModel.options; }\n    fireEvent(event) { this.treeModel.fireEvent(event); }\n    // field accessors:\n    get displayField() {\n        return this.getField('display');\n    }\n    get id() {\n        return this.getField('id');\n    }\n    set id(value) {\n        this.setField('id', value);\n    }\n    getField(key) {\n        return this.data[this.options[`${key}Field`]];\n    }\n    setField(key, value) {\n        this.data[this.options[`${key}Field`]] = value;\n    }\n    // traversing:\n    _findAdjacentSibling(steps, skipHidden = false) {\n        const siblings = this._getParentsChildren(skipHidden);\n        const index = siblings.indexOf(this);\n        return siblings.length > index + steps ? siblings[index + steps] : null;\n    }\n    findNextSibling(skipHidden = false) {\n        return this._findAdjacentSibling(+1, skipHidden);\n    }\n    findPreviousSibling(skipHidden = false) {\n        return this._findAdjacentSibling(-1, skipHidden);\n    }\n    getVisibleChildren() {\n        return this.visibleChildren;\n    }\n    get visibleChildren() {\n        return (this.children || []).filter((node) => !node.isHidden);\n    }\n    getFirstChild(skipHidden = false) {\n        let children = skipHidden ? this.visibleChildren : this.children;\n        return children != null && children.length ? children[0] : null;\n    }\n    getLastChild(skipHidden = false) {\n        let children = skipHidden ? this.visibleChildren : this.children;\n        return children != null && children.length ? children[children.length - 1] : null;\n    }\n    findNextNode(goInside = true, skipHidden = false) {\n        return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||\n            this.findNextSibling(skipHidden) ||\n            this.parent && this.parent.findNextNode(false, skipHidden);\n    }\n    findPreviousNode(skipHidden = false) {\n        let previousSibling = this.findPreviousSibling(skipHidden);\n        if (!previousSibling) {\n            return this.realParent;\n        }\n        return previousSibling._getLastOpenDescendant(skipHidden);\n    }\n    _getLastOpenDescendant(skipHidden = false) {\n        const lastChild = this.getLastChild(skipHidden);\n        return (this.isCollapsed || !lastChild)\n            ? this\n            : lastChild._getLastOpenDescendant(skipHidden);\n    }\n    _getParentsChildren(skipHidden = false) {\n        const children = this.parent &&\n            (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);\n        return children || [];\n    }\n    getIndexInParent(skipHidden = false) {\n        return this._getParentsChildren(skipHidden).indexOf(this);\n    }\n    isDescendantOf(node) {\n        if (this === node)\n            return true;\n        else\n            return this.parent && this.parent.isDescendantOf(node);\n    }\n    getNodePadding() {\n        return this.options.levelPadding * (this.level - 1) + 'px';\n    }\n    getClass() {\n        return [this.options.nodeClass(this), `tree-node-level-${this.level}`].join(' ');\n    }\n    onDrop($event) {\n        this.mouseAction('drop', $event.event, {\n            from: $event.element,\n            to: { parent: this, index: 0, dropOnNode: true }\n        });\n    }\n    allowDrop = (element, $event) => {\n        return this.options.allowDrop(element, { parent: this, index: 0 }, $event);\n    };\n    allowDragoverStyling = () => {\n        return this.options.allowDragoverStyling;\n    };\n    allowDrag() {\n        return this.options.allowDrag(this);\n    }\n    // helper methods:\n    loadNodeChildren() {\n        if (!this.options.getChildren) {\n            return Promise.resolve(); // Not getChildren method - for using redux\n        }\n        return Promise.resolve(this.options.getChildren(this))\n            .then((children) => {\n            if (children) {\n                this.setField('children', children);\n                this._initChildren();\n                if (this.options.useTriState && this.treeModel.isSelected(this)) {\n                    this.setIsSelected(true);\n                }\n                this.children.forEach((child) => {\n                    if (child.getField('isExpanded') && child.hasChildren) {\n                        child.expand();\n                    }\n                });\n            }\n        }).then(() => {\n            this.fireEvent({\n                eventName: TREE_EVENTS.loadNodeChildren,\n                node: this\n            });\n        });\n    }\n    expand() {\n        if (!this.isExpanded) {\n            this.toggleExpanded();\n        }\n        return this;\n    }\n    collapse() {\n        if (this.isExpanded) {\n            this.toggleExpanded();\n        }\n        return this;\n    }\n    doForAll(fn) {\n        Promise.resolve(fn(this)).then(() => {\n            if (this.children) {\n                this.children.forEach((child) => child.doForAll(fn));\n            }\n        });\n    }\n    expandAll() {\n        this.doForAll((node) => node.expand());\n    }\n    collapseAll() {\n        this.doForAll((node) => node.collapse());\n    }\n    ensureVisible() {\n        if (this.realParent) {\n            this.realParent.expand();\n            this.realParent.ensureVisible();\n        }\n        return this;\n    }\n    toggleExpanded() {\n        this.setIsExpanded(!this.isExpanded);\n        return this;\n    }\n    setIsExpanded(value) {\n        if (this.hasChildren) {\n            this.treeModel.setExpandedNode(this, value);\n        }\n        return this;\n    }\n    ;\n    autoLoadChildren() {\n        this.handler =\n            reaction(() => this.isExpanded, (isExpanded) => {\n                if (!this.children && this.hasChildren && isExpanded) {\n                    this.loadNodeChildren();\n                }\n            }, { fireImmediately: true });\n    }\n    dispose() {\n        if (this.children) {\n            this.children.forEach((child) => child.dispose());\n        }\n        if (this.handler) {\n            this.handler();\n        }\n        this.parent = null;\n        this.children = null;\n    }\n    setIsActive(value, multi = false) {\n        this.treeModel.setActiveNode(this, value, multi);\n        if (value) {\n            this.focus(this.options.scrollOnActivate);\n        }\n        return this;\n    }\n    isSelectable() {\n        return this.isLeaf || !this.children || !this.options.useTriState;\n    }\n    setIsSelected(value) {\n        if (this.isSelectable()) {\n            this.treeModel.setSelectedNode(this, value);\n        }\n        else {\n            this.visibleChildren.forEach((child) => child.setIsSelected(value));\n        }\n        return this;\n    }\n    toggleSelected() {\n        this.setIsSelected(!this.isSelected);\n        return this;\n    }\n    toggleActivated(multi = false) {\n        this.setIsActive(!this.isActive, multi);\n        return this;\n    }\n    setActiveAndVisible(multi = false) {\n        this.setIsActive(true, multi)\n            .ensureVisible();\n        setTimeout(this.scrollIntoView.bind(this));\n        return this;\n    }\n    scrollIntoView(force = false) {\n        this.treeModel.virtualScroll.scrollIntoView(this, force);\n    }\n    focus(scroll = true) {\n        let previousNode = this.treeModel.getFocusedNode();\n        this.treeModel.setFocusedNode(this);\n        if (scroll) {\n            this.scrollIntoView();\n        }\n        if (previousNode) {\n            this.fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });\n        }\n        this.fireEvent({ eventName: TREE_EVENTS.focus, node: this });\n        return this;\n    }\n    blur() {\n        let previousNode = this.treeModel.getFocusedNode();\n        this.treeModel.setFocusedNode(null);\n        if (previousNode) {\n            this.fireEvent({ eventName: TREE_EVENTS.blur, node: this });\n        }\n        return this;\n    }\n    setIsHidden(value) {\n        this.treeModel.setIsHidden(this, value);\n    }\n    hide() {\n        this.setIsHidden(true);\n    }\n    show() {\n        this.setIsHidden(false);\n    }\n    mouseAction(actionName, $event, data = null) {\n        this.treeModel.setFocus(true);\n        const actionMapping = this.options.actionMapping.mouse;\n        const mouseAction = actionMapping[actionName];\n        if (mouseAction) {\n            mouseAction(this.treeModel, this, $event, data);\n        }\n    }\n    getSelfHeight() {\n        return this.options.nodeHeight(this);\n    }\n    _initChildren() {\n        this.children = this.getField('children')\n            .map((c, index) => new TreeNode(c, this, this.treeModel, index));\n    }\n}\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isHidden\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isExpanded\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isActive\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isFocused\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isSelected\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isAllSelected\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isPartiallySelected\", null);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Array)\n], TreeNode.prototype, \"children\", void 0);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Number)\n], TreeNode.prototype, \"index\", void 0);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Object)\n], TreeNode.prototype, \"position\", void 0);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Number)\n], TreeNode.prototype, \"height\", void 0);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Number),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"level\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Array),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"path\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"visibleChildren\", null);\n__decorate$3([\n    action$1,\n    __metadata$3(\"design:type\", Function),\n    __metadata$3(\"design:paramtypes\", [Object]),\n    __metadata$3(\"design:returntype\", void 0)\n], TreeNode.prototype, \"setIsSelected\", null);\n__decorate$3([\n    action$1,\n    __metadata$3(\"design:type\", Function),\n    __metadata$3(\"design:paramtypes\", []),\n    __metadata$3(\"design:returntype\", void 0)\n], TreeNode.prototype, \"_initChildren\", null);\nfunction uuid() {\n    return Math.floor(Math.random() * 10000000000000);\n}","originalLength":44598,"removedExports":[],"renderedExports":["TreeNode"],"renderedLength":14030},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree.model.mjs":{"code":"var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$2 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nclass TreeModel {\n    static focusedTree = null;\n    options = new TreeOptions();\n    nodes;\n    eventNames = Object.keys(TREE_EVENTS);\n    virtualScroll;\n    roots;\n    expandedNodeIds = {};\n    selectedLeafNodeIds = {};\n    activeNodeIds = {};\n    hiddenNodeIds = {};\n    focusedNodeId = null;\n    virtualRoot;\n    firstUpdate = true;\n    events;\n    subscriptions = [];\n    // events\n    fireEvent(event) {\n        event.treeModel = this;\n        this.events[event.eventName].emit(event);\n        this.events.event.emit(event);\n    }\n    subscribe(eventName, fn) {\n        const subscription = this.events[eventName].subscribe(fn);\n        this.subscriptions.push(subscription);\n    }\n    // getters\n    getFocusedNode() {\n        return this.focusedNode;\n    }\n    getActiveNode() {\n        return this.activeNodes[0];\n    }\n    getActiveNodes() {\n        return this.activeNodes;\n    }\n    getVisibleRoots() {\n        return this.virtualRoot.visibleChildren;\n    }\n    getFirstRoot(skipHidden = false) {\n        const root = skipHidden ? this.getVisibleRoots() : this.roots;\n        return root != null && root.length ? root[0] : null;\n    }\n    getLastRoot(skipHidden = false) {\n        const root = skipHidden ? this.getVisibleRoots() : this.roots;\n        return root != null && root.length ? root[root.length - 1] : null;\n    }\n    get isFocused() {\n        return TreeModel.focusedTree === this;\n    }\n    isNodeFocused(node) {\n        return this.focusedNode === node;\n    }\n    isEmptyTree() {\n        return this.roots && this.roots.length === 0;\n    }\n    get focusedNode() {\n        return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;\n    }\n    get expandedNodes() {\n        const nodes = Object.keys(this.expandedNodeIds)\n            .filter((id) => this.expandedNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    get activeNodes() {\n        const nodes = Object.keys(this.activeNodeIds)\n            .filter((id) => this.activeNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    get hiddenNodes() {\n        const nodes = Object.keys(this.hiddenNodeIds)\n            .filter((id) => this.hiddenNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    get selectedLeafNodes() {\n        const nodes = Object.keys(this.selectedLeafNodeIds)\n            .filter((id) => this.selectedLeafNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    // locating nodes\n    getNodeByPath(path, startNode = null) {\n        if (!path)\n            return null;\n        startNode = startNode || this.virtualRoot;\n        if (path.length === 0)\n            return startNode;\n        if (!startNode.children)\n            return null;\n        const childId = path.shift();\n        const childNode = startNode.children.find(c => c.id === childId);\n        if (!childNode)\n            return null;\n        return this.getNodeByPath(path, childNode);\n    }\n    getNodeById(id) {\n        const idStr = id.toString();\n        return this.getNodeBy((node) => node.id.toString() === idStr);\n    }\n    getNodeBy(predicate, startNode = null) {\n        startNode = startNode || this.virtualRoot;\n        if (!startNode.children)\n            return null;\n        const found = startNode.children.find(predicate);\n        if (found) { // found in children\n            return found;\n        }\n        else { // look in children's children\n            for (let child of startNode.children) {\n                const foundInChildren = this.getNodeBy(predicate, child);\n                if (foundInChildren)\n                    return foundInChildren;\n            }\n        }\n    }\n    isExpanded(node) {\n        return this.expandedNodeIds[node.id];\n    }\n    isHidden(node) {\n        return this.hiddenNodeIds[node.id];\n    }\n    isActive(node) {\n        return this.activeNodeIds[node.id];\n    }\n    isSelected(node) {\n        return this.selectedLeafNodeIds[node.id];\n    }\n    ngOnDestroy() {\n        this.dispose();\n        this.unsubscribeAll();\n    }\n    dispose() {\n        // Dispose reactions of the replaced nodes\n        if (this.virtualRoot) {\n            this.virtualRoot.dispose();\n        }\n    }\n    unsubscribeAll() {\n        this.subscriptions.forEach(subscription => subscription.unsubscribe());\n        this.subscriptions = [];\n    }\n    // actions\n    setData({ nodes, options = null, events = null }) {\n        if (options) {\n            this.options = new TreeOptions(options);\n        }\n        if (events) {\n            this.events = events;\n        }\n        if (nodes) {\n            this.nodes = nodes;\n        }\n        this.update();\n    }\n    update() {\n        // Rebuild tree:\n        let virtualRootConfig = {\n            id: this.options.rootId,\n            virtual: true,\n            [this.options.childrenField]: this.nodes\n        };\n        this.dispose();\n        this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);\n        this.roots = this.virtualRoot.children;\n        // Fire event:\n        if (this.firstUpdate) {\n            if (this.roots) {\n                this.firstUpdate = false;\n                this._calculateExpandedNodes();\n            }\n        }\n        else {\n            this.fireEvent({ eventName: TREE_EVENTS.updateData });\n        }\n    }\n    setFocusedNode(node) {\n        this.focusedNodeId = node ? node.id : null;\n    }\n    setFocus(value) {\n        TreeModel.focusedTree = value ? this : null;\n    }\n    doForAll(fn) {\n        this.roots.forEach((root) => root.doForAll(fn));\n    }\n    focusNextNode() {\n        let previousNode = this.getFocusedNode();\n        let nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);\n        if (nextNode)\n            nextNode.focus();\n    }\n    focusPreviousNode() {\n        let previousNode = this.getFocusedNode();\n        let nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);\n        if (nextNode)\n            nextNode.focus();\n    }\n    focusDrillDown() {\n        let previousNode = this.getFocusedNode();\n        if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {\n            previousNode.toggleExpanded();\n        }\n        else {\n            let nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);\n            if (nextNode)\n                nextNode.focus();\n        }\n    }\n    focusDrillUp() {\n        let previousNode = this.getFocusedNode();\n        if (!previousNode)\n            return;\n        if (previousNode.isExpanded) {\n            previousNode.toggleExpanded();\n        }\n        else {\n            let nextNode = previousNode.realParent;\n            if (nextNode)\n                nextNode.focus();\n        }\n    }\n    setActiveNode(node, value, multi = false) {\n        if (multi) {\n            this._setActiveNodeMulti(node, value);\n        }\n        else {\n            this._setActiveNodeSingle(node, value);\n        }\n        if (value) {\n            node.focus(this.options.scrollOnActivate);\n            this.fireEvent({ eventName: TREE_EVENTS.activate, node });\n            this.fireEvent({ eventName: TREE_EVENTS.nodeActivate, node }); // For IE11\n        }\n        else {\n            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node });\n            this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node }); // For IE11\n        }\n    }\n    setSelectedNode(node, value) {\n        this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, { [node.id]: value });\n        if (value) {\n            node.focus();\n            this.fireEvent({ eventName: TREE_EVENTS.select, node });\n        }\n        else {\n            this.fireEvent({ eventName: TREE_EVENTS.deselect, node });\n        }\n    }\n    setExpandedNode(node, value) {\n        this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, { [node.id]: value });\n        this.fireEvent({ eventName: TREE_EVENTS.toggleExpanded, node, isExpanded: value });\n    }\n    expandAll() {\n        this.roots.forEach((root) => root.expandAll());\n    }\n    collapseAll() {\n        this.roots.forEach((root) => root.collapseAll());\n    }\n    setIsHidden(node, value) {\n        this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, { [node.id]: value });\n    }\n    setHiddenNodeIds(nodeIds) {\n        this.hiddenNodeIds = nodeIds.reduce((hiddenNodeIds, id) => Object.assign(hiddenNodeIds, {\n            [id]: true\n        }), {});\n    }\n    performKeyAction(node, $event) {\n        const keyAction = this.options.actionMapping.keys[$event.keyCode];\n        if (keyAction) {\n            $event.preventDefault();\n            keyAction(this, node, $event);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    filterNodes(filter, autoShow = true) {\n        let filterFn;\n        if (!filter) {\n            return this.clearFilter();\n        }\n        // support function and string filter\n        if (filter && typeof filter.valueOf() === 'string') {\n            filterFn = (node) => node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1;\n        }\n        else if (filter && typeof filter === 'function') {\n            filterFn = filter;\n        }\n        else {\n            console.error('Don\\'t know what to do with filter', filter);\n            console.error('Should be either a string or function');\n            return;\n        }\n        const ids = {};\n        this.roots.forEach((node) => this._filterNode(ids, node, filterFn, autoShow));\n        this.hiddenNodeIds = ids;\n        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });\n    }\n    clearFilter() {\n        this.hiddenNodeIds = {};\n        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });\n    }\n    moveNode(node, to) {\n        const fromIndex = node.getIndexInParent();\n        const fromParent = node.parent;\n        if (!this.canMoveNode(node, to, fromIndex))\n            return;\n        const fromChildren = fromParent.getField('children');\n        // If node doesn't have children - create children array\n        if (!to.parent.getField('children')) {\n            to.parent.setField('children', []);\n        }\n        const toChildren = to.parent.getField('children');\n        const originalNode = fromChildren.splice(fromIndex, 1)[0];\n        // Compensate for index if already removed from parent:\n        let toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;\n        toChildren.splice(toIndex, 0, originalNode);\n        fromParent.treeModel.update();\n        if (to.parent.treeModel !== fromParent.treeModel) {\n            to.parent.treeModel.update();\n        }\n        this.fireEvent({\n            eventName: TREE_EVENTS.moveNode,\n            node: originalNode,\n            to: { parent: to.parent.data, index: toIndex },\n            from: { parent: fromParent.data, index: fromIndex }\n        });\n    }\n    copyNode(node, to) {\n        const fromIndex = node.getIndexInParent();\n        if (!this.canMoveNode(node, to, fromIndex))\n            return;\n        // If node doesn't have children - create children array\n        if (!to.parent.getField('children')) {\n            to.parent.setField('children', []);\n        }\n        const toChildren = to.parent.getField('children');\n        const nodeCopy = this.options.getNodeClone(node);\n        toChildren.splice(to.index, 0, nodeCopy);\n        node.treeModel.update();\n        if (to.parent.treeModel !== node.treeModel) {\n            to.parent.treeModel.update();\n        }\n        this.fireEvent({ eventName: TREE_EVENTS.copyNode, node: nodeCopy, to: { parent: to.parent.data, index: to.index } });\n    }\n    getState() {\n        return {\n            expandedNodeIds: this.expandedNodeIds,\n            selectedLeafNodeIds: this.selectedLeafNodeIds,\n            activeNodeIds: this.activeNodeIds,\n            hiddenNodeIds: this.hiddenNodeIds,\n            focusedNodeId: this.focusedNodeId\n        };\n    }\n    setState(state) {\n        if (!state)\n            return;\n        Object.assign(this, {\n            expandedNodeIds: state.expandedNodeIds || {},\n            selectedLeafNodeIds: state.selectedLeafNodeIds || {},\n            activeNodeIds: state.activeNodeIds || {},\n            hiddenNodeIds: state.hiddenNodeIds || {},\n            focusedNodeId: state.focusedNodeId\n        });\n    }\n    subscribeToState(fn) {\n        autorun(() => fn(this.getState()));\n    }\n    canMoveNode(node, to, fromIndex = undefined) {\n        const fromNodeIndex = fromIndex || node.getIndexInParent();\n        // same node:\n        if (node.parent === to.parent && fromIndex === to.index) {\n            return false;\n        }\n        return !to.parent.isDescendantOf(node);\n    }\n    calculateExpandedNodes() {\n        this._calculateExpandedNodes();\n    }\n    // private methods\n    _filterNode(ids, node, filterFn, autoShow) {\n        // if node passes function then it's visible\n        let isVisible = filterFn(node);\n        if (node.children) {\n            // if one of node's children passes filter then this node is also visible\n            node.children.forEach((child) => {\n                if (this._filterNode(ids, child, filterFn, autoShow)) {\n                    isVisible = true;\n                }\n            });\n        }\n        // mark node as hidden\n        if (!isVisible) {\n            ids[node.id] = true;\n        }\n        // auto expand parents to make sure the filtered nodes are visible\n        if (autoShow && isVisible) {\n            node.ensureVisible();\n        }\n        return isVisible;\n    }\n    _calculateExpandedNodes(startNode = null) {\n        startNode = startNode || this.virtualRoot;\n        if (startNode.data[this.options.isExpandedField]) {\n            this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, { [startNode.id]: true });\n        }\n        if (startNode.children) {\n            startNode.children.forEach((child) => this._calculateExpandedNodes(child));\n        }\n    }\n    _setActiveNodeSingle(node, value) {\n        // Deactivate all other nodes:\n        this.activeNodes\n            .filter((activeNode) => activeNode !== node)\n            .forEach((activeNode) => {\n            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });\n            this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node: activeNode }); // For IE11\n        });\n        if (value) {\n            this.activeNodeIds = { [node.id]: true };\n        }\n        else {\n            this.activeNodeIds = {};\n        }\n    }\n    _setActiveNodeMulti(node, value) {\n        this.activeNodeIds = Object.assign({}, this.activeNodeIds, { [node.id]: value });\n    }\n    /** @nocollapse */ static ɵfac = function TreeModel_Factory(t) { return new (t || TreeModel)(); };\n    /** @nocollapse */ static ɵprov = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjectable({ token: TreeModel, factory: TreeModel.ɵfac });\n}\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Array)\n], TreeModel.prototype, \"roots\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"expandedNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"selectedLeafNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"activeNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"hiddenNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"focusedNodeId\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", TreeNode)\n], TreeModel.prototype, \"virtualRoot\", void 0);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"focusedNode\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"expandedNodes\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"activeNodes\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"hiddenNodes\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"selectedLeafNodes\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setData\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"update\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setFocusedNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setFocus\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"doForAll\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusNextNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusPreviousNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusDrillDown\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusDrillUp\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setActiveNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setSelectedNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setExpandedNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"expandAll\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"collapseAll\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setIsHidden\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setHiddenNodeIds\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"filterNodes\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"clearFilter\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"moveNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"copyNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setState\", null);\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeModel, [{\n        type: Injectable\n    }], null, { roots: [], expandedNodeIds: [], selectedLeafNodeIds: [], activeNodeIds: [], hiddenNodeIds: [], focusedNodeId: [], virtualRoot: [], focusedNode: [], expandedNodes: [], activeNodes: [], hiddenNodes: [], selectedLeafNodes: [], setData: [], update: [], setFocusedNode: [], setFocus: [], doForAll: [], focusNextNode: [], focusPreviousNode: [], focusDrillDown: [], focusDrillUp: [], setActiveNode: [], setSelectedNode: [], setExpandedNode: [], expandAll: [], collapseAll: [], setIsHidden: [], setHiddenNodeIds: [], filterNodes: [], clearFilter: [], moveNode: [], copyNode: [], setState: [] }); })();","originalLength":64791,"removedExports":[],"renderedExports":["TreeModel"],"renderedLength":22701},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-dragged-element.model.mjs":{"code":"class TreeDraggedElement {\n    _draggedElement = null;\n    set(draggedElement) {\n        this._draggedElement = draggedElement;\n    }\n    get() {\n        return this._draggedElement;\n    }\n    isDragging() {\n        return !!this.get();\n    }\n    /** @nocollapse */ static ɵfac = function TreeDraggedElement_Factory(t) { return new (t || TreeDraggedElement)(); };\n    /** @nocollapse */ static ɵprov = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjectable({ token: TreeDraggedElement, factory: TreeDraggedElement.ɵfac, providedIn: 'root' });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeDraggedElement, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], null, null); })();","originalLength":2172,"removedExports":[],"renderedExports":["TreeDraggedElement"],"renderedLength":761},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/models/tree-virtual-scroll.model.mjs":{"code":"var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$1 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\nconst Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\nclass TreeVirtualScroll {\n    treeModel;\n    _dispose;\n    yBlocks = 0;\n    x = 0;\n    viewportHeight = null;\n    viewport = null;\n    get y() {\n        return this.yBlocks * Y_EPSILON;\n    }\n    get totalHeight() {\n        return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\n    }\n    constructor(treeModel) {\n        this.treeModel = treeModel;\n        treeModel.virtualScroll = this;\n        this._dispose = [autorun(() => this.fixScroll())];\n    }\n    fireEvent(event) {\n        this.treeModel.fireEvent(event);\n    }\n    init() {\n        const fn = this.recalcPositions.bind(this);\n        fn();\n        this._dispose = [\n            ...this._dispose,\n            reaction(() => this.treeModel.roots, fn),\n            reaction(() => this.treeModel.expandedNodeIds, fn),\n            reaction(() => this.treeModel.hiddenNodeIds, fn)\n        ];\n        this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\n    }\n    isEnabled() {\n        return this.treeModel.options.useVirtualScroll;\n    }\n    _setYBlocks(value) {\n        this.yBlocks = value;\n    }\n    recalcPositions() {\n        this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\n    }\n    _getPositionAfter(nodes, startPos) {\n        let position = startPos;\n        nodes.forEach((node) => {\n            node.position = position;\n            position = this._getPositionAfterNode(node, position);\n        });\n        return position;\n    }\n    _getPositionAfterNode(node, startPos) {\n        let position = node.getSelfHeight() + startPos;\n        if (node.children && node.isExpanded) { // TBD: consider loading component as well\n            position = this._getPositionAfter(node.visibleChildren, position);\n        }\n        node.height = position - startPos;\n        return position;\n    }\n    clear() {\n        this._dispose.forEach((d) => d());\n    }\n    setViewport(viewport) {\n        Object.assign(this, {\n            viewport,\n            x: viewport.scrollLeft,\n            yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\n            viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\n        });\n    }\n    scrollIntoView(node, force, scrollToMiddle = true) {\n        if (node.options.scrollContainer) {\n            const scrollContainer = node.options.scrollContainer;\n            const scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\n            const scrollContainerTop = scrollContainer.getBoundingClientRect().top;\n            const nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\n            if (force || // force scroll to node\n                nodeTop < scrollContainer.scrollTop || // node is above scroll container\n                nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) { // node is below container\n                scrollContainer.scrollTop = scrollToMiddle ?\n                    nodeTop - scrollContainerHeight / 2 : // scroll to middle\n                    nodeTop; // scroll to start\n            }\n        }\n        else {\n            if (force || // force scroll to node\n                node.position < this.y || // node is above viewport\n                node.position + node.getSelfHeight() > this.y + this.viewportHeight) { // node is below viewport\n                if (this.viewport) {\n                    this.viewport.scrollTop = scrollToMiddle ?\n                        node.position - this.viewportHeight / 2 : // scroll to middle\n                        node.position; // scroll to start\n                    this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\n                }\n            }\n        }\n    }\n    getViewportNodes(nodes) {\n        if (!nodes)\n            return [];\n        const visibleNodes = nodes.filter((node) => !node.isHidden);\n        if (!this.isEnabled())\n            return visibleNodes;\n        if (!this.viewportHeight || !visibleNodes.length)\n            return [];\n        // When loading children async this method is called before their height and position is calculated.\n        // In that case firstIndex === 0 and lastIndex === visibleNodes.length - 1 (e.g. 1000),\n        // which means that it loops through every visibleNodes item and push them into viewportNodes array.\n        // We can prevent nodes from being pushed to the array and wait for the appropriate calculations to take place\n        const lastVisibleNode = visibleNodes.slice(-1)[0];\n        if (!lastVisibleNode.height && lastVisibleNode.position === 0)\n            return [];\n        // Search for first node in the viewport using binary search\n        // Look for first node that starts after the beginning of the viewport (with buffer)\n        // Or that ends after the beginning of the viewport\n        const firstIndex = binarySearch(visibleNodes, (node) => {\n            return (node.position + Y_OFFSET > this.y) ||\n                (node.position + node.height > this.y);\n        });\n        // Search for last node in the viewport using binary search\n        // Look for first node that starts after the end of the viewport (with buffer)\n        const lastIndex = binarySearch(visibleNodes, (node) => {\n            return node.position - Y_OFFSET > this.y + this.viewportHeight;\n        }, firstIndex);\n        const viewportNodes = [];\n        for (let i = firstIndex; i <= lastIndex; i++) {\n            viewportNodes.push(visibleNodes[i]);\n        }\n        return viewportNodes;\n    }\n    fixScroll() {\n        const maxY = Math.max(0, this.totalHeight - this.viewportHeight);\n        if (this.y < 0)\n            this._setYBlocks(0);\n        if (this.y > maxY)\n            this._setYBlocks(maxY / Y_EPSILON);\n    }\n    /** @nocollapse */ static ɵfac = function TreeVirtualScroll_Factory(t) { return new (t || TreeVirtualScroll)(i0.ɵɵinject(TreeModel)); };\n    /** @nocollapse */ static ɵprov = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjectable({ token: TreeVirtualScroll, factory: TreeVirtualScroll.ɵfac });\n}\n__decorate$1([\n    observable$1,\n    __metadata$1(\"design:type\", Object)\n], TreeVirtualScroll.prototype, \"yBlocks\", void 0);\n__decorate$1([\n    observable$1,\n    __metadata$1(\"design:type\", Object)\n], TreeVirtualScroll.prototype, \"x\", void 0);\n__decorate$1([\n    observable$1,\n    __metadata$1(\"design:type\", Object)\n], TreeVirtualScroll.prototype, \"viewportHeight\", void 0);\n__decorate$1([\n    computed$1,\n    __metadata$1(\"design:type\", Object),\n    __metadata$1(\"design:paramtypes\", [])\n], TreeVirtualScroll.prototype, \"y\", null);\n__decorate$1([\n    computed$1,\n    __metadata$1(\"design:type\", Object),\n    __metadata$1(\"design:paramtypes\", [])\n], TreeVirtualScroll.prototype, \"totalHeight\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", [Object]),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"_setYBlocks\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", []),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"recalcPositions\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", [Object]),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"setViewport\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", [Object, Object, Object]),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"scrollIntoView\", null);\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeVirtualScroll, [{\n        type: Injectable\n    }], () => [{ type: TreeModel }], { yBlocks: [], x: [], viewportHeight: [], y: [], totalHeight: [], _setYBlocks: [], recalcPositions: [], setViewport: [], scrollIntoView: [] }); })();\nfunction binarySearch(nodes, condition, firstIndex = 0) {\n    let index = firstIndex;\n    let toIndex = nodes.length - 1;\n    while (index !== toIndex) {\n        let midIndex = Math.floor((index + toIndex) / 2);\n        if (condition(nodes[midIndex])) {\n            toIndex = midIndex;\n        }\n        else {\n            if (index === midIndex)\n                index = toIndex;\n            else\n                index = midIndex;\n        }\n    }\n    return index;\n}","originalLength":26364,"removedExports":[],"renderedExports":["TreeVirtualScroll"],"renderedLength":9388},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/loading.component.mjs":{"code":"const _c0$9 = a0 => ({ $implicit: a0 });\nfunction LoadingComponent_span_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \"loading...\");\n    i0.ɵɵelementEnd();\n} }\nclass LoadingComponent {\n    template;\n    node;\n    /** @nocollapse */ static ɵfac = function LoadingComponent_Factory(t) { return new (t || LoadingComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: LoadingComponent, selectors: [[\"tree-loading-component\"]], inputs: { template: \"template\", node: \"node\" }, decls: 2, vars: 5, consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]], template: function LoadingComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, LoadingComponent_span_0_Template, 2, 0, \"span\", 0);\n            i0.ɵɵelementContainer(1, 1);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"ngIf\", !ctx.template);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c0$9, ctx.node));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoadingComponent, [{\n        type: Component,\n        args: [{\n                encapsulation: ViewEncapsulation.None,\n                selector: 'tree-loading-component',\n                template: `\n    <span *ngIf=\"!template\">loading...</span>\n    <ng-container\n      [ngTemplateOutlet]=\"template\"\n      [ngTemplateOutletContext]=\"{ $implicit: node }\">\n    </ng-container>\n  `,\n            }]\n    }], null, { template: [{\n            type: Input\n        }], node: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(LoadingComponent, { className: \"LoadingComponent\" }); })();","originalLength":3828,"removedExports":[],"renderedExports":["LoadingComponent"],"renderedLength":1898},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-viewport.component.mjs":{"code":"const _c0$8 = [\"*\"];\nconst _c1$2 = () => ({ dontDetach: true });\nfunction TreeViewportComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\");\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵstyleProp(\"height\", ctx_r0.getTotalHeight());\n} }\nclass TreeViewportComponent {\n    elementRef;\n    virtualScroll;\n    setViewport = this.throttle(() => {\n        this.virtualScroll.setViewport(this.elementRef.nativeElement);\n    }, 17);\n    scrollEventHandler;\n    constructor(elementRef, virtualScroll) {\n        this.elementRef = elementRef;\n        this.virtualScroll = virtualScroll;\n        this.scrollEventHandler = this.setViewport.bind(this);\n    }\n    ngOnInit() {\n        this.virtualScroll.init();\n    }\n    ngAfterViewInit() {\n        setTimeout(() => {\n            this.setViewport();\n            this.virtualScroll.fireEvent({ eventName: TREE_EVENTS.initialized });\n        });\n        let el = this.elementRef.nativeElement;\n        el.addEventListener('scroll', this.scrollEventHandler);\n    }\n    ngOnDestroy() {\n        this.virtualScroll.clear();\n        let el = this.elementRef.nativeElement;\n        el.removeEventListener('scroll', this.scrollEventHandler);\n    }\n    getTotalHeight() {\n        return ((this.virtualScroll.isEnabled() &&\n            this.virtualScroll.totalHeight + 'px') ||\n            'auto');\n    }\n    throttle(func, timeFrame) {\n        let lastTime = 0;\n        return function () {\n            let now = Date.now();\n            if (now - lastTime >= timeFrame) {\n                func();\n                lastTime = now;\n            }\n        };\n    }\n    /** @nocollapse */ static ɵfac = function TreeViewportComponent_Factory(t) { return new (t || TreeViewportComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TreeVirtualScroll)); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeViewportComponent, selectors: [[\"tree-viewport\"]], features: [i0.ɵɵProvidersFeature([TreeVirtualScroll])], ngContentSelectors: _c0$8, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"]], template: function TreeViewportComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵprojectionDef();\n            i0.ɵɵtemplate(0, TreeViewportComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c1$2));\n        } }, dependencies: [TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeViewportComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-viewport', providers: [TreeVirtualScroll], template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.height]=\"getTotalHeight()\">\n        <ng-content></ng-content>\n      </div>\n    </ng-container>\n  ` }]\n    }], () => [{ type: i0.ElementRef }, { type: TreeVirtualScroll }], null); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeViewportComponent, { className: \"TreeViewportComponent\" }); })();","originalLength":8704,"removedExports":[],"renderedExports":["TreeViewportComponent"],"renderedLength":3282},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/directives/tree-drop.directive.mjs":{"code":"const DRAG_OVER_CLASS$1 = 'is-dragging-over';\nconst DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';\nclass TreeDropDirective {\n    el;\n    renderer;\n    treeDraggedElement;\n    ngZone;\n    allowDragoverStyling = true;\n    onDropCallback = new EventEmitter();\n    onDragOverCallback = new EventEmitter();\n    onDragLeaveCallback = new EventEmitter();\n    onDragEnterCallback = new EventEmitter();\n    dragOverEventHandler;\n    dragEnterEventHandler;\n    dragLeaveEventHandler;\n    _allowDrop = (element, $event) => true;\n    set treeAllowDrop(allowDrop) {\n        if (allowDrop instanceof Function) {\n            this._allowDrop = allowDrop;\n        }\n        else\n            this._allowDrop = (element, $event) => allowDrop;\n    }\n    allowDrop($event) {\n        return this._allowDrop(this.treeDraggedElement.get(), $event);\n    }\n    constructor(el, renderer, treeDraggedElement, ngZone) {\n        this.el = el;\n        this.renderer = renderer;\n        this.treeDraggedElement = treeDraggedElement;\n        this.ngZone = ngZone;\n        this.dragOverEventHandler = this.onDragOver.bind(this);\n        this.dragEnterEventHandler = this.onDragEnter.bind(this);\n        this.dragLeaveEventHandler = this.onDragLeave.bind(this);\n    }\n    ngAfterViewInit() {\n        let el = this.el.nativeElement;\n        this.ngZone.runOutsideAngular(() => {\n            el.addEventListener('dragover', this.dragOverEventHandler);\n            el.addEventListener('dragenter', this.dragEnterEventHandler);\n            el.addEventListener('dragleave', this.dragLeaveEventHandler);\n        });\n    }\n    ngOnDestroy() {\n        let el = this.el.nativeElement;\n        el.removeEventListener('dragover', this.dragOverEventHandler);\n        el.removeEventListener('dragenter', this.dragEnterEventHandler);\n        el.removeEventListener('dragleave', this.dragLeaveEventHandler);\n    }\n    onDragOver($event) {\n        if (!this.allowDrop($event)) {\n            if (this.allowDragoverStyling) {\n                return this.addDisabledClass();\n            }\n            return;\n        }\n        this.onDragOverCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n        $event.preventDefault();\n        if (this.allowDragoverStyling) {\n            this.addClass();\n        }\n    }\n    onDragEnter($event) {\n        if (!this.allowDrop($event))\n            return;\n        $event.preventDefault();\n        this.onDragEnterCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n    }\n    onDragLeave($event) {\n        if (!this.allowDrop($event)) {\n            if (this.allowDragoverStyling) {\n                return this.removeDisabledClass();\n            }\n            return;\n        }\n        this.onDragLeaveCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n        if (this.allowDragoverStyling) {\n            this.removeClass();\n        }\n    }\n    onDrop($event) {\n        if (!this.allowDrop($event))\n            return;\n        $event.preventDefault();\n        this.onDropCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n        if (this.allowDragoverStyling) {\n            this.removeClass();\n        }\n        this.treeDraggedElement.set(null);\n    }\n    addClass() {\n        this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS$1);\n    }\n    removeClass() {\n        this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS$1);\n    }\n    addDisabledClass() {\n        this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n    }\n    removeDisabledClass() {\n        this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n    }\n    /** @nocollapse */ static ɵfac = function TreeDropDirective_Factory(t) { return new (t || TreeDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(TreeDraggedElement), i0.ɵɵdirectiveInject(i0.NgZone)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeDropDirective, selectors: [[\"\", \"treeDrop\", \"\"]], hostBindings: function TreeDropDirective_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"drop\", function TreeDropDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); });\n        } }, inputs: { allowDragoverStyling: \"allowDragoverStyling\", treeAllowDrop: \"treeAllowDrop\" }, outputs: { onDropCallback: \"treeDrop\", onDragOverCallback: \"treeDropDragOver\", onDragLeaveCallback: \"treeDropDragLeave\", onDragEnterCallback: \"treeDropDragEnter\" } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeDropDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[treeDrop]'\n            }]\n    }], () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: TreeDraggedElement }, { type: i0.NgZone }], { allowDragoverStyling: [{\n            type: Input\n        }], onDropCallback: [{\n            type: Output,\n            args: ['treeDrop']\n        }], onDragOverCallback: [{\n            type: Output,\n            args: ['treeDropDragOver']\n        }], onDragLeaveCallback: [{\n            type: Output,\n            args: ['treeDropDragLeave']\n        }], onDragEnterCallback: [{\n            type: Output,\n            args: ['treeDropDragEnter']\n        }], treeAllowDrop: [{\n            type: Input\n        }], onDrop: [{\n            type: HostListener,\n            args: ['drop', ['$event']]\n        }] }); })();","originalLength":16727,"removedExports":[],"renderedExports":["TreeDropDirective"],"renderedLength":5468},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-drop-slot.component.mjs":{"code":"class TreeNodeDropSlot {\n    node;\n    dropIndex;\n    onDrop($event) {\n        this.node.mouseAction('drop', $event.event, {\n            from: $event.element,\n            to: { parent: this.node, index: this.dropIndex }\n        });\n    }\n    allowDrop(element, $event) {\n        return this.node.options.allowDrop(element, { parent: this.node, index: this.dropIndex }, $event);\n    }\n    /** @nocollapse */ static ɵfac = function TreeNodeDropSlot_Factory(t) { return new (t || TreeNodeDropSlot)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeDropSlot, selectors: [[\"TreeNodeDropSlot\"], [\"tree-node-drop-slot\"]], inputs: { node: \"node\", dropIndex: \"dropIndex\" }, decls: 1, vars: 2, consts: [[1, \"node-drop-slot\", 3, \"treeDrop\", \"treeAllowDrop\", \"allowDragoverStyling\"]], template: function TreeNodeDropSlot_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0);\n            i0.ɵɵlistener(\"treeDrop\", function TreeNodeDropSlot_Template_div_treeDrop_0_listener($event) { return ctx.onDrop($event); });\n            i0.ɵɵelementEnd();\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeAllowDrop\", ctx.allowDrop.bind(ctx))(\"allowDragoverStyling\", true);\n        } }, dependencies: [TreeDropDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeDropSlot, [{\n        type: Component,\n        args: [{ selector: 'TreeNodeDropSlot, tree-node-drop-slot', encapsulation: ViewEncapsulation.None, template: `\n    <div\n      class=\"node-drop-slot\"\n      (treeDrop)=\"onDrop($event)\"\n      [treeAllowDrop]=\"allowDrop.bind(this)\"\n      [allowDragoverStyling]=\"true\">\n    </div>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], dropIndex: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeDropSlot, { className: \"TreeNodeDropSlot\" }); })();","originalLength":4803,"removedExports":[],"renderedExports":["TreeNodeDropSlot"],"renderedLength":1985},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/mobx-angular/mobx-proxy.mjs":{"code":"// Re-export mobx operators to be able to use inside components with AOT:\nfunction actionInternal(...args) {\n    return action$1(...args);\n}\nconst action = Object.assign(actionInternal, action$1);\nfunction computedInternal(...args) {\n    return computed$1(...args);\n}\nconst computed = Object.assign(computedInternal, computed$1);\nfunction observableInternal(...args) {\n    return observable$1(...args);\n}\nconst observable = Object.assign(observableInternal, observable$1);","originalLength":2938,"removedExports":[],"renderedExports":["actionInternal","action","computed","observable"],"renderedLength":472},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-collection.component.mjs":{"code":"var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _c0$7 = () => ({ dontDetach: true });\nfunction TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node\", 2);\n} if (rf & 2) {\n    const node_r1 = ctx.$implicit;\n    const i_r2 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"node\", node_r1)(\"index\", i_r2)(\"templates\", ctx_r2.templates);\n} }\nfunction TreeNodeCollectionComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\");\n    i0.ɵɵtemplate(2, TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template, 1, 3, \"tree-node\", 1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵstyleProp(\"margin-top\", ctx_r2.marginTop);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.viewportNodes)(\"ngForTrackBy\", ctx_r2.trackNode);\n} }\nclass TreeNodeCollectionComponent {\n    get nodes() {\n        return this._nodes;\n    }\n    set nodes(nodes) {\n        this.setNodes(nodes);\n    }\n    treeModel;\n    _nodes;\n    virtualScroll; // Cannot inject this, because we might be inside treeNodeTemplateFull\n    templates;\n    viewportNodes;\n    get marginTop() {\n        const firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];\n        const relativePosition = firstNode && firstNode.parent\n            ? firstNode.position -\n                firstNode.parent.position -\n                firstNode.parent.getSelfHeight()\n            : 0;\n        return `${relativePosition}px`;\n    }\n    _dispose = [];\n    setNodes(nodes) {\n        this._nodes = nodes;\n    }\n    ngOnInit() {\n        this.virtualScroll = this.treeModel.virtualScroll;\n        this._dispose = [\n            // return node indexes so we can compare structurally,\n            reaction(() => {\n                return this.virtualScroll\n                    .getViewportNodes(this.nodes)\n                    .map(n => n.index);\n            }, nodeIndexes => {\n                this.viewportNodes = nodeIndexes.map(i => this.nodes[i]);\n            }, { compareStructural: true, fireImmediately: true }),\n            reaction(() => this.nodes, nodes => {\n                this.viewportNodes = this.virtualScroll.getViewportNodes(nodes);\n            })\n        ];\n    }\n    ngOnDestroy() {\n        this._dispose.forEach(d => d());\n    }\n    trackNode(index, node) {\n        return node.id;\n    }\n    /** @nocollapse */ static ɵfac = function TreeNodeCollectionComponent_Factory(t) { return new (t || TreeNodeCollectionComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeCollectionComponent, selectors: [[\"tree-node-collection\"]], inputs: { nodes: \"nodes\", treeModel: \"treeModel\", templates: \"templates\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [3, \"node\", \"index\", \"templates\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"node\", \"index\", \"templates\"]], template: function TreeNodeCollectionComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeCollectionComponent_ng_container_0_Template, 3, 4, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$7));\n        } }, encapsulation: 2 });\n}\n__decorate([\n    observable,\n    __metadata(\"design:type\", Object)\n], TreeNodeCollectionComponent.prototype, \"_nodes\", void 0);\n__decorate([\n    observable,\n    __metadata(\"design:type\", Array)\n], TreeNodeCollectionComponent.prototype, \"viewportNodes\", void 0);\n__decorate([\n    computed,\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [])\n], TreeNodeCollectionComponent.prototype, \"marginTop\", null);\n__decorate([\n    action,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], TreeNodeCollectionComponent.prototype, \"setNodes\", null);\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeCollectionComponent, [{\n        type: Component,\n        args: [{\n                selector: 'tree-node-collection',\n                encapsulation: ViewEncapsulation.None,\n                template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.margin-top]=\"marginTop\">\n        <tree-node\n          *ngFor=\"let node of viewportNodes; let i = index; trackBy: trackNode\"\n          [node]=\"node\"\n          [index]=\"i\"\n          [templates]=\"templates\"\n        >\n        </tree-node>\n      </div>\n    </ng-container>\n  `\n            }]\n    }], null, { nodes: [{\n            type: Input\n        }], treeModel: [{\n            type: Input\n        }], _nodes: [], templates: [{\n            type: Input\n        }], viewportNodes: [], marginTop: [], setNodes: [] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeCollectionComponent, { className: \"TreeNodeCollectionComponent\" }); })();","originalLength":12873,"removedExports":[],"renderedExports":["TreeNodeCollectionComponent"],"renderedLength":5787},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree.component.mjs":{"code":"const _c0$6 = [\"loadingTemplate\"];\nconst _c1$1 = [\"treeNodeTemplate\"];\nconst _c2 = [\"treeNodeWrapperTemplate\"];\nconst _c3 = [\"treeNodeFullTemplate\"];\nconst _c4 = [\"viewport\"];\nconst _c5 = (a0, a1, a2, a3) => ({ loadingTemplate: a0, treeNodeTemplate: a1, treeNodeWrapperTemplate: a2, treeNodeFullTemplate: a3 });\nfunction TreeComponent_tree_node_collection_3_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-collection\", 4);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"nodes\", ctx_r0.treeModel.roots)(\"treeModel\", ctx_r0.treeModel)(\"templates\", i0.ɵɵpureFunction4(3, _c5, ctx_r0.loadingTemplate, ctx_r0.treeNodeTemplate, ctx_r0.treeNodeWrapperTemplate, ctx_r0.treeNodeFullTemplate));\n} }\nfunction TreeComponent_tree_node_drop_slot_4_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-drop-slot\", 5);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"dropIndex\", 0)(\"node\", ctx_r0.treeModel.virtualRoot);\n} }\nclass TreeComponent {\n    treeModel;\n    treeDraggedElement;\n    _nodes;\n    _options;\n    loadingTemplate;\n    treeNodeTemplate;\n    treeNodeWrapperTemplate;\n    treeNodeFullTemplate;\n    viewportComponent;\n    // Will be handled in ngOnChanges\n    set nodes(nodes) {\n    }\n    ;\n    set options(options) {\n    }\n    ;\n    set focused(value) {\n        this.treeModel.setFocus(value);\n    }\n    set state(state) {\n        this.treeModel.setState(state);\n    }\n    toggleExpanded;\n    activate;\n    deactivate;\n    nodeActivate;\n    nodeDeactivate;\n    select;\n    deselect;\n    focus;\n    blur;\n    updateData;\n    initialized;\n    moveNode;\n    copyNode;\n    loadNodeChildren;\n    changeFilter;\n    event;\n    stateChange;\n    constructor(treeModel, treeDraggedElement) {\n        this.treeModel = treeModel;\n        this.treeDraggedElement = treeDraggedElement;\n        treeModel.eventNames.forEach((name) => this[name] = new EventEmitter());\n        treeModel.subscribeToState((state) => this.stateChange.emit(state));\n    }\n    onKeydown($event) {\n        if (!this.treeModel.isFocused)\n            return;\n        if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase()))\n            return;\n        const focusedNode = this.treeModel.getFocusedNode();\n        this.treeModel.performKeyAction(focusedNode, $event);\n    }\n    onMousedown($event) {\n        function isOutsideClick(startElement, nodeName) {\n            return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);\n        }\n        if (isOutsideClick($event.target, 'tree-root')) {\n            this.treeModel.setFocus(false);\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes.options || changes.nodes) {\n            this.treeModel.setData({\n                options: changes.options && changes.options.currentValue,\n                nodes: changes.nodes && changes.nodes.currentValue,\n                events: this.pick(this, this.treeModel.eventNames)\n            });\n        }\n    }\n    sizeChanged() {\n        this.viewportComponent.setViewport();\n    }\n    pick(object, keys) {\n        return keys.reduce((obj, key) => {\n            if (object && object.hasOwnProperty(key)) {\n                obj[key] = object[key];\n            }\n            return obj;\n        }, {});\n    }\n    /** @nocollapse */ static ɵfac = function TreeComponent_Factory(t) { return new (t || TreeComponent)(i0.ɵɵdirectiveInject(TreeModel), i0.ɵɵdirectiveInject(TreeDraggedElement)); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeComponent, selectors: [[\"Tree\"], [\"tree-root\"]], contentQueries: function TreeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n            i0.ɵɵcontentQuery(dirIndex, _c0$6, 5);\n            i0.ɵɵcontentQuery(dirIndex, _c1$1, 5);\n            i0.ɵɵcontentQuery(dirIndex, _c2, 5);\n            i0.ɵɵcontentQuery(dirIndex, _c3, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingTemplate = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeTemplate = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeWrapperTemplate = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeFullTemplate = _t.first);\n        } }, viewQuery: function TreeComponent_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵɵviewQuery(_c4, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewportComponent = _t.first);\n        } }, hostBindings: function TreeComponent_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"keydown\", function TreeComponent_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); }, false, i0.ɵɵresolveBody)(\"mousedown\", function TreeComponent_mousedown_HostBindingHandler($event) { return ctx.onMousedown($event); }, false, i0.ɵɵresolveBody);\n        } }, inputs: { nodes: \"nodes\", options: \"options\", focused: \"focused\", state: \"state\" }, outputs: { toggleExpanded: \"toggleExpanded\", activate: \"activate\", deactivate: \"deactivate\", nodeActivate: \"nodeActivate\", nodeDeactivate: \"nodeDeactivate\", select: \"select\", deselect: \"deselect\", focus: \"focus\", blur: \"blur\", updateData: \"updateData\", initialized: \"initialized\", moveNode: \"moveNode\", copyNode: \"copyNode\", loadNodeChildren: \"loadNodeChildren\", changeFilter: \"changeFilter\", event: \"event\", stateChange: \"stateChange\" }, features: [i0.ɵɵProvidersFeature([TreeModel]), i0.ɵɵNgOnChangesFeature], decls: 5, vars: 6, consts: [[\"viewport\", \"\"], [1, \"angular-tree-component\"], [3, \"nodes\", \"treeModel\", \"templates\", 4, \"ngIf\"], [\"class\", \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"treeModel\", \"templates\"], [1, \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\"]], template: function TreeComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"tree-viewport\", null, 0)(2, \"div\", 1);\n            i0.ɵɵtemplate(3, TreeComponent_tree_node_collection_3_Template, 1, 8, \"tree-node-collection\", 2)(4, TreeComponent_tree_node_drop_slot_4_Template, 1, 2, \"tree-node-drop-slot\", 3);\n            i0.ɵɵelementEnd()();\n        } if (rf & 2) {\n            i0.ɵɵadvance(2);\n            i0.ɵɵclassProp(\"node-dragging\", ctx.treeDraggedElement.isDragging())(\"angular-tree-component-rtl\", ctx.treeModel.options.rtl);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.treeModel.roots);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.treeModel.isEmptyTree());\n        } }, dependencies: [i1.NgIf, TreeNodeDropSlot, TreeNodeCollectionComponent, TreeViewportComponent], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeComponent, [{\n        type: Component,\n        args: [{ selector: 'Tree, tree-root', providers: [TreeModel], template: `\n      <tree-viewport #viewport>\n          <div\n                  class=\"angular-tree-component\"\n                  [class.node-dragging]=\"treeDraggedElement.isDragging()\"\n                  [class.angular-tree-component-rtl]=\"treeModel.options.rtl\">\n              <tree-node-collection\n                      *ngIf=\"treeModel.roots\"\n                      [nodes]=\"treeModel.roots\"\n                      [treeModel]=\"treeModel\"\n                      [templates]=\"{\n            loadingTemplate: loadingTemplate,\n            treeNodeTemplate: treeNodeTemplate,\n            treeNodeWrapperTemplate: treeNodeWrapperTemplate,\n            treeNodeFullTemplate: treeNodeFullTemplate\n          }\">\n              </tree-node-collection>\n              <tree-node-drop-slot\n                      class=\"empty-tree-drop-slot\"\n                      *ngIf=\"treeModel.isEmptyTree()\"\n                      [dropIndex]=\"0\"\n                      [node]=\"treeModel.virtualRoot\">\n              </tree-node-drop-slot>\n          </div>\n      </tree-viewport>\n  ` }]\n    }], () => [{ type: TreeModel }, { type: TreeDraggedElement }], { loadingTemplate: [{\n            type: ContentChild,\n            args: ['loadingTemplate', { static: false }]\n        }], treeNodeTemplate: [{\n            type: ContentChild,\n            args: ['treeNodeTemplate', { static: false }]\n        }], treeNodeWrapperTemplate: [{\n            type: ContentChild,\n            args: ['treeNodeWrapperTemplate', { static: false }]\n        }], treeNodeFullTemplate: [{\n            type: ContentChild,\n            args: ['treeNodeFullTemplate', { static: false }]\n        }], viewportComponent: [{\n            type: ViewChild,\n            args: ['viewport', { static: false }]\n        }], nodes: [{\n            type: Input\n        }], options: [{\n            type: Input\n        }], focused: [{\n            type: Input\n        }], state: [{\n            type: Input\n        }], toggleExpanded: [{\n            type: Output\n        }], activate: [{\n            type: Output\n        }], deactivate: [{\n            type: Output\n        }], nodeActivate: [{\n            type: Output\n        }], nodeDeactivate: [{\n            type: Output\n        }], select: [{\n            type: Output\n        }], deselect: [{\n            type: Output\n        }], focus: [{\n            type: Output\n        }], blur: [{\n            type: Output\n        }], updateData: [{\n            type: Output\n        }], initialized: [{\n            type: Output\n        }], moveNode: [{\n            type: Output\n        }], copyNode: [{\n            type: Output\n        }], loadNodeChildren: [{\n            type: Output\n        }], changeFilter: [{\n            type: Output\n        }], event: [{\n            type: Output\n        }], stateChange: [{\n            type: Output\n        }], onKeydown: [{\n            type: HostListener,\n            args: ['body: keydown', ['$event']]\n        }], onMousedown: [{\n            type: HostListener,\n            args: ['body: mousedown', ['$event']]\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeComponent, { className: \"TreeComponent\" }); })();","originalLength":22423,"removedExports":[],"renderedExports":["TreeComponent"],"renderedLength":10136},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/directives/tree-animate-open.directive.mjs":{"code":"const EASE_ACCELERATION = 1.005;\nclass TreeAnimateOpenDirective {\n    renderer;\n    templateRef;\n    viewContainerRef;\n    _isOpen;\n    animateSpeed;\n    animateAcceleration;\n    isEnabled;\n    set isOpen(value) {\n        if (value) {\n            this._show();\n            if (this.isEnabled && this._isOpen === false) {\n                this._animateOpen();\n            }\n        }\n        else {\n            this.isEnabled ? this._animateClose() : this._hide();\n        }\n        this._isOpen = !!value;\n    }\n    ;\n    innerElement;\n    constructor(renderer, templateRef, viewContainerRef) {\n        this.renderer = renderer;\n        this.templateRef = templateRef;\n        this.viewContainerRef = viewContainerRef;\n    }\n    _show() {\n        if (this.innerElement)\n            return;\n        // create child view\n        this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];\n    }\n    _hide() {\n        this.viewContainerRef.clear();\n        this.innerElement = null;\n    }\n    _animateOpen() {\n        let delta = this.animateSpeed;\n        let ease = this.animateAcceleration;\n        let maxHeight = 0;\n        // set height to 0\n        this.renderer.setStyle(this.innerElement, 'max-height', `0`);\n        // increase maxHeight until height doesn't change\n        setTimeout(() => {\n            const i = setInterval(() => {\n                if (!this._isOpen || !this.innerElement)\n                    return clearInterval(i);\n                maxHeight += delta;\n                const roundedMaxHeight = Math.round(maxHeight);\n                this.renderer.setStyle(this.innerElement, 'max-height', `${roundedMaxHeight}px`);\n                const height = this.innerElement.getBoundingClientRect ? this.innerElement.getBoundingClientRect().height : 0; // TBD use renderer\n                delta *= ease;\n                ease *= EASE_ACCELERATION;\n                if (height < roundedMaxHeight) {\n                    // Make maxHeight auto because animation finished and container might change height later on\n                    this.renderer.setStyle(this.innerElement, 'max-height', null);\n                    clearInterval(i);\n                }\n            }, 17);\n        });\n    }\n    _animateClose() {\n        if (!this.innerElement)\n            return;\n        let delta = this.animateSpeed;\n        let ease = this.animateAcceleration;\n        let height = this.innerElement.getBoundingClientRect().height; // TBD use renderer\n        // slowly decrease maxHeight to 0, starting from current height\n        const i = setInterval(() => {\n            if (this._isOpen || !this.innerElement)\n                return clearInterval(i);\n            height -= delta;\n            this.renderer.setStyle(this.innerElement, 'max-height', `${height}px`);\n            delta *= ease;\n            ease *= EASE_ACCELERATION;\n            if (height <= 0) {\n                // after animation complete - remove child element\n                this.viewContainerRef.clear();\n                this.innerElement = null;\n                clearInterval(i);\n            }\n        }, 17);\n    }\n    /** @nocollapse */ static ɵfac = function TreeAnimateOpenDirective_Factory(t) { return new (t || TreeAnimateOpenDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeAnimateOpenDirective, selectors: [[\"\", \"treeAnimateOpen\", \"\"]], inputs: { animateSpeed: [i0.ɵɵInputFlags.None, \"treeAnimateOpenSpeed\", \"animateSpeed\"], animateAcceleration: [i0.ɵɵInputFlags.None, \"treeAnimateOpenAcceleration\", \"animateAcceleration\"], isEnabled: [i0.ɵɵInputFlags.None, \"treeAnimateOpenEnabled\", \"isEnabled\"], isOpen: [i0.ɵɵInputFlags.None, \"treeAnimateOpen\", \"isOpen\"] } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeAnimateOpenDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[treeAnimateOpen]'\n            }]\n    }], () => [{ type: i0.Renderer2 }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }], { animateSpeed: [{\n            type: Input,\n            args: ['treeAnimateOpenSpeed']\n        }], animateAcceleration: [{\n            type: Input,\n            args: ['treeAnimateOpenAcceleration']\n        }], isEnabled: [{\n            type: Input,\n            args: ['treeAnimateOpenEnabled']\n        }], isOpen: [{\n            type: Input,\n            args: ['treeAnimateOpen']\n        }] }); })();","originalLength":13208,"removedExports":[],"renderedExports":["TreeAnimateOpenDirective"],"renderedLength":4569},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-children.component.mjs":{"code":"const _c0$5 = () => ({ dontDetach: true });\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-collection\", 4);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"nodes\", ctx_r0.node.children)(\"templates\", ctx_r0.templates)(\"treeModel\", ctx_r0.node.treeModel);\n} }\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-loading-component\", 5);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"padding-left\", ctx_r0.node.getNodePadding());\n    i0.ɵɵproperty(\"template\", ctx_r0.templates.loadingTemplate)(\"node\", ctx_r0.node);\n} }\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template, 1, 3, \"tree-node-collection\", 2)(2, TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template, 1, 4, \"tree-loading-component\", 3);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"tree-children\", true)(\"tree-children-no-padding\", ctx_r0.node.options.levelPadding);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.node.children);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.node.children);\n} }\nfunction TreeNodeChildrenComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_Template, 3, 6, \"div\", 1);\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"treeAnimateOpen\", ctx_r0.node.isExpanded)(\"treeAnimateOpenSpeed\", ctx_r0.node.options.animateSpeed)(\"treeAnimateOpenAcceleration\", ctx_r0.node.options.animateAcceleration)(\"treeAnimateOpenEnabled\", ctx_r0.node.options.animateExpand);\n} }\nclass TreeNodeChildrenComponent {\n    node;\n    templates;\n    /** @nocollapse */ static ɵfac = function TreeNodeChildrenComponent_Factory(t) { return new (t || TreeNodeChildrenComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeChildrenComponent, selectors: [[\"tree-node-children\"]], inputs: { node: \"node\", templates: \"templates\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [3, \"tree-children\", \"tree-children-no-padding\", 4, \"treeAnimateOpen\", \"treeAnimateOpenSpeed\", \"treeAnimateOpenAcceleration\", \"treeAnimateOpenEnabled\"], [3, \"nodes\", \"templates\", \"treeModel\", 4, \"ngIf\"], [\"class\", \"tree-node-loading\", 3, \"padding-left\", \"template\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"templates\", \"treeModel\"], [1, \"tree-node-loading\", 3, \"template\", \"node\"]], template: function TreeNodeChildrenComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeChildrenComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$5));\n        } }, dependencies: [i1.NgIf, LoadingComponent, TreeNodeCollectionComponent, TreeAnimateOpenDirective, TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeChildrenComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-children', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div\n        [class.tree-children]=\"true\"\n        [class.tree-children-no-padding]=\"node.options.levelPadding\"\n        *treeAnimateOpen=\"\n          node.isExpanded;\n          speed: node.options.animateSpeed;\n          acceleration: node.options.animateAcceleration;\n          enabled: node.options.animateExpand\n        \"\n      >\n        <tree-node-collection\n          *ngIf=\"node.children\"\n          [nodes]=\"node.children\"\n          [templates]=\"templates\"\n          [treeModel]=\"node.treeModel\"\n        >\n        </tree-node-collection>\n        <tree-loading-component\n          [style.padding-left]=\"node.getNodePadding()\"\n          class=\"tree-node-loading\"\n          *ngIf=\"!node.children\"\n          [template]=\"templates.loadingTemplate\"\n          [node]=\"node\"\n        ></tree-loading-component>\n      </div>\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], templates: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeChildrenComponent, { className: \"TreeNodeChildrenComponent\" }); })();","originalLength":8233,"removedExports":[],"renderedExports":["TreeNodeChildrenComponent"],"renderedLength":4741},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-content.component.mjs":{"code":"const _c0$4 = (a0, a1, a2) => ({ $implicit: a0, node: a1, index: a2 });\nfunction TreeNodeContent_span_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r0.node.displayField);\n} }\nclass TreeNodeContent {\n    node;\n    index;\n    template;\n    /** @nocollapse */ static ɵfac = function TreeNodeContent_Factory(t) { return new (t || TreeNodeContent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeContent, selectors: [[\"tree-node-content\"]], inputs: { node: \"node\", index: \"index\", template: \"template\" }, decls: 2, vars: 7, consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]], template: function TreeNodeContent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeContent_span_0_Template, 2, 1, \"span\", 0);\n            i0.ɵɵelementContainer(1, 1);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"ngIf\", !ctx.template);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(3, _c0$4, ctx.node, ctx.node, ctx.index));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeContent, [{\n        type: Component,\n        args: [{\n                selector: 'tree-node-content',\n                encapsulation: ViewEncapsulation.None,\n                template: `\n  <span *ngIf=\"!template\">{{ node.displayField }}</span>\n  <ng-container\n    [ngTemplateOutlet]=\"template\"\n    [ngTemplateOutletContext]=\"{ $implicit: node, node: node, index: index }\">\n  </ng-container>`,\n            }]\n    }], null, { node: [{\n            type: Input\n        }], index: [{\n            type: Input\n        }], template: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeContent, { className: \"TreeNodeContent\" }); })();","originalLength":4232,"removedExports":[],"renderedExports":["TreeNodeContent"],"renderedLength":2142},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/directives/tree-drag.directive.mjs":{"code":"const DRAG_OVER_CLASS = 'is-dragging-over';\nclass TreeDragDirective {\n    el;\n    renderer;\n    treeDraggedElement;\n    ngZone;\n    draggedElement;\n    treeDragEnabled;\n    dragEventHandler;\n    constructor(el, renderer, treeDraggedElement, ngZone) {\n        this.el = el;\n        this.renderer = renderer;\n        this.treeDraggedElement = treeDraggedElement;\n        this.ngZone = ngZone;\n        this.dragEventHandler = this.onDrag.bind(this);\n    }\n    ngAfterViewInit() {\n        let el = this.el.nativeElement;\n        this.ngZone.runOutsideAngular(() => {\n            el.addEventListener('drag', this.dragEventHandler);\n        });\n    }\n    ngDoCheck() {\n        this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\n    }\n    ngOnDestroy() {\n        let el = this.el.nativeElement;\n        el.removeEventListener('drag', this.dragEventHandler);\n    }\n    onDragStart(ev) {\n        // setting the data is required by firefox\n        ev.dataTransfer.setData('text', ev.target.id);\n        this.treeDraggedElement.set(this.draggedElement);\n        if (this.draggedElement.mouseAction) {\n            this.draggedElement.mouseAction('dragStart', ev);\n        }\n    }\n    onDrag(ev) {\n        if (this.draggedElement.mouseAction) {\n            this.draggedElement.mouseAction('drag', ev);\n        }\n    }\n    onDragEnd() {\n        if (this.draggedElement.mouseAction) {\n            this.draggedElement.mouseAction('dragEnd');\n        }\n        this.treeDraggedElement.set(null);\n    }\n    /** @nocollapse */ static ɵfac = function TreeDragDirective_Factory(t) { return new (t || TreeDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(TreeDraggedElement), i0.ɵɵdirectiveInject(i0.NgZone)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeDragDirective, selectors: [[\"\", \"treeDrag\", \"\"]], hostBindings: function TreeDragDirective_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"dragstart\", function TreeDragDirective_dragstart_HostBindingHandler($event) { return ctx.onDragStart($event); })(\"dragend\", function TreeDragDirective_dragend_HostBindingHandler() { return ctx.onDragEnd(); });\n        } }, inputs: { draggedElement: [i0.ɵɵInputFlags.None, \"treeDrag\", \"draggedElement\"], treeDragEnabled: \"treeDragEnabled\" } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeDragDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[treeDrag]'\n            }]\n    }], () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: TreeDraggedElement }, { type: i0.NgZone }], { draggedElement: [{\n            type: Input,\n            args: ['treeDrag']\n        }], treeDragEnabled: [{\n            type: Input\n        }], onDragStart: [{\n            type: HostListener,\n            args: ['dragstart', ['$event']]\n        }], onDragEnd: [{\n            type: HostListener,\n            args: ['dragend']\n        }] }); })();","originalLength":8621,"removedExports":[],"renderedExports":["TreeDragDirective"],"renderedLength":3062},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-expander.component.mjs":{"code":"const _c0$3 = () => ({ dontDetach: true });\nfunction TreeNodeExpanderComponent_ng_container_0_span_1_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵlistener(\"click\", function TreeNodeExpanderComponent_ng_container_0_span_1_Template_span_click_0_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"expanderClick\", $event)); });\n    i0.ɵɵelement(1, \"span\", 4);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"toggle-children-wrapper-expanded\", ctx_r1.node.isExpanded)(\"toggle-children-wrapper-collapsed\", ctx_r1.node.isCollapsed);\n} }\nfunction TreeNodeExpanderComponent_ng_container_0_span_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 5);\n} }\nfunction TreeNodeExpanderComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeNodeExpanderComponent_ng_container_0_span_1_Template, 2, 4, \"span\", 1)(2, TreeNodeExpanderComponent_ng_container_0_span_2_Template, 1, 0, \"span\", 2);\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.node.hasChildren);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.node.hasChildren);\n} }\nclass TreeNodeExpanderComponent {\n    node;\n    /** @nocollapse */ static ɵfac = function TreeNodeExpanderComponent_Factory(t) { return new (t || TreeNodeExpanderComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeExpanderComponent, selectors: [[\"tree-node-expander\"]], inputs: { node: \"node\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [\"class\", \"toggle-children-wrapper\", 3, \"toggle-children-wrapper-expanded\", \"toggle-children-wrapper-collapsed\", \"click\", 4, \"ngIf\"], [\"class\", \"toggle-children-placeholder\", 4, \"ngIf\"], [1, \"toggle-children-wrapper\", 3, \"click\"], [1, \"toggle-children\"], [1, \"toggle-children-placeholder\"]], template: function TreeNodeExpanderComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeExpanderComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$3));\n        } }, dependencies: [i1.NgIf, TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeExpanderComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-expander', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <span\n        *ngIf=\"node.hasChildren\"\n        [class.toggle-children-wrapper-expanded]=\"node.isExpanded\"\n        [class.toggle-children-wrapper-collapsed]=\"node.isCollapsed\"\n        class=\"toggle-children-wrapper\"\n        (click)=\"node.mouseAction('expanderClick', $event)\"\n      >\n        <span class=\"toggle-children\"></span>\n      </span>\n      <span *ngIf=\"!node.hasChildren\" class=\"toggle-children-placeholder\">\n      </span>\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeExpanderComponent, { className: \"TreeNodeExpanderComponent\" }); })();","originalLength":5955,"removedExports":[],"renderedExports":["TreeNodeExpanderComponent"],"renderedLength":3452},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-checkbox.component.mjs":{"code":"const _c0$2 = () => ({ dontDetach: true });\nfunction TreeNodeCheckboxComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"input\", 1);\n    i0.ɵɵlistener(\"click\", function TreeNodeCheckboxComponent_ng_container_0_Template_input_click_1_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"checkboxClick\", $event)); });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"checked\", ctx_r1.node.isSelected)(\"indeterminate\", ctx_r1.node.isPartiallySelected);\n} }\nclass TreeNodeCheckboxComponent {\n    node;\n    /** @nocollapse */ static ɵfac = function TreeNodeCheckboxComponent_Factory(t) { return new (t || TreeNodeCheckboxComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeCheckboxComponent, selectors: [[\"tree-node-checkbox\"]], inputs: { node: \"node\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [\"type\", \"checkbox\", 1, \"tree-node-checkbox\", 3, \"click\", \"checked\", \"indeterminate\"]], template: function TreeNodeCheckboxComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeCheckboxComponent_ng_container_0_Template, 2, 2, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$2));\n        } }, dependencies: [TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeCheckboxComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-checkbox', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <input\n        class=\"tree-node-checkbox\"\n        type=\"checkbox\"\n        (click)=\"node.mouseAction('checkboxClick', $event)\"\n        [checked]=\"node.isSelected\"\n        [indeterminate]=\"node.isPartiallySelected\"\n      />\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeCheckboxComponent, { className: \"TreeNodeCheckboxComponent\" }); })();","originalLength":4419,"removedExports":[],"renderedExports":["TreeNodeCheckboxComponent"],"renderedLength":2375},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node-wrapper.component.mjs":{"code":"const _c0$1 = (a0, a1, a2, a3) => ({ $implicit: a0, node: a1, index: a2, templates: a3 });\nfunction TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-checkbox\", 4);\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"node\", ctx_r1.node);\n} }\nfunction TreeNodeWrapperComponent_div_0_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtemplate(1, TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template, 1, 1, \"tree-node-checkbox\", 3);\n    i0.ɵɵelement(2, \"tree-node-expander\", 4);\n    i0.ɵɵelementStart(3, \"div\", 5);\n    i0.ɵɵlistener(\"click\", function TreeNodeWrapperComponent_div_0_Template_div_click_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"click\", $event)); })(\"dblclick\", function TreeNodeWrapperComponent_div_0_Template_div_dblclick_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dblClick\", $event)); })(\"mouseover\", function TreeNodeWrapperComponent_div_0_Template_div_mouseover_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"mouseOver\", $event)); })(\"mouseout\", function TreeNodeWrapperComponent_div_0_Template_div_mouseout_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"mouseOut\", $event)); })(\"contextmenu\", function TreeNodeWrapperComponent_div_0_Template_div_contextmenu_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"contextMenu\", $event)); })(\"treeDrop\", function TreeNodeWrapperComponent_div_0_Template_div_treeDrop_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.onDrop($event)); })(\"treeDropDragOver\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragOver_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dragOver\", $event)); })(\"treeDropDragLeave\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragLeave_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dragLeave\", $event)); })(\"treeDropDragEnter\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragEnter_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dragEnter\", $event)); });\n    i0.ɵɵelement(4, \"tree-node-content\", 6);\n    i0.ɵɵelementEnd()();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"padding-left\", ctx_r1.node.getNodePadding());\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.node.options.useCheckbox);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r1.node);\n    i0.ɵɵadvance();\n    i0.ɵɵclassProp(\"node-content-wrapper-active\", ctx_r1.node.isActive)(\"node-content-wrapper-focused\", ctx_r1.node.isFocused);\n    i0.ɵɵproperty(\"treeAllowDrop\", ctx_r1.node.allowDrop)(\"allowDragoverStyling\", ctx_r1.node.allowDragoverStyling())(\"treeDrag\", ctx_r1.node)(\"treeDragEnabled\", ctx_r1.node.allowDrag());\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r1.node)(\"index\", ctx_r1.index)(\"template\", ctx_r1.templates.treeNodeTemplate);\n} }\nclass TreeNodeWrapperComponent {\n    node;\n    index;\n    templates;\n    /** @nocollapse */ static ɵfac = function TreeNodeWrapperComponent_Factory(t) { return new (t || TreeNodeWrapperComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeWrapperComponent, selectors: [[\"tree-node-wrapper\"]], inputs: { node: \"node\", index: \"index\", templates: \"templates\" }, decls: 2, vars: 8, consts: [[\"class\", \"node-wrapper\", 3, \"padding-left\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"node-wrapper\"], [3, \"node\", 4, \"ngIf\"], [3, \"node\"], [1, \"node-content-wrapper\", 3, \"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"contextmenu\", \"treeDrop\", \"treeDropDragOver\", \"treeDropDragLeave\", \"treeDropDragEnter\", \"treeAllowDrop\", \"allowDragoverStyling\", \"treeDrag\", \"treeDragEnabled\"], [3, \"node\", \"index\", \"template\"]], template: function TreeNodeWrapperComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeWrapperComponent_div_0_Template, 5, 15, \"div\", 0);\n            i0.ɵɵelementContainer(1, 1);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"ngIf\", !ctx.templates.treeNodeWrapperTemplate);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templates.treeNodeWrapperTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(3, _c0$1, ctx.node, ctx.node, ctx.index, ctx.templates));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet, TreeNodeContent, TreeDropDirective, TreeDragDirective, TreeNodeExpanderComponent, TreeNodeCheckboxComponent], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeWrapperComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-wrapper', encapsulation: ViewEncapsulation.None, template: `\n      <div *ngIf=\"!templates.treeNodeWrapperTemplate\" class=\"node-wrapper\" [style.padding-left]=\"node.getNodePadding()\">\n          <tree-node-checkbox *ngIf=\"node.options.useCheckbox\" [node]=\"node\"></tree-node-checkbox>\n          <tree-node-expander [node]=\"node\"></tree-node-expander>\n          <div class=\"node-content-wrapper\"\n               [class.node-content-wrapper-active]=\"node.isActive\"\n               [class.node-content-wrapper-focused]=\"node.isFocused\"\n               (click)=\"node.mouseAction('click', $event)\"\n               (dblclick)=\"node.mouseAction('dblClick', $event)\"\n               (mouseover)=\"node.mouseAction('mouseOver', $event)\"\n               (mouseout)=\"node.mouseAction('mouseOut', $event)\"\n               (contextmenu)=\"node.mouseAction('contextMenu', $event)\"\n               (treeDrop)=\"node.onDrop($event)\"\n               (treeDropDragOver)=\"node.mouseAction('dragOver', $event)\"\n               (treeDropDragLeave)=\"node.mouseAction('dragLeave', $event)\"\n               (treeDropDragEnter)=\"node.mouseAction('dragEnter', $event)\"\n               [treeAllowDrop]=\"node.allowDrop\"\n               [allowDragoverStyling]=\"node.allowDragoverStyling()\"\n               [treeDrag]=\"node\"\n               [treeDragEnabled]=\"node.allowDrag()\">\n\n              <tree-node-content [node]=\"node\" [index]=\"index\" [template]=\"templates.treeNodeTemplate\">\n              </tree-node-content>\n          </div>\n      </div>\n      <ng-container\n              [ngTemplateOutlet]=\"templates.treeNodeWrapperTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: node, node: node, index: index, templates: templates }\">\n      </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], index: [{\n            type: Input\n        }], templates: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeWrapperComponent, { className: \"TreeNodeWrapperComponent\" }); })();","originalLength":12512,"removedExports":[],"renderedExports":["TreeNodeWrapperComponent"],"renderedLength":7381},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/components/tree-node.component.mjs":{"code":"const _c0 = () => ({ dontDetach: true });\nconst _c1 = (a0, a1, a2, a3) => ({ $implicit: a0, node: a1, index: a2, templates: a3 });\nfunction TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-drop-slot\", 6);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"dropIndex\", ctx_r0.node.index)(\"node\", ctx_r0.node.parent);\n} }\nfunction TreeNodeComponent_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template, 1, 2, \"tree-node-drop-slot\", 3);\n    i0.ɵɵelement(2, \"tree-node-wrapper\", 4)(3, \"tree-node-children\", 5)(4, \"tree-node-drop-slot\", 6);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r0.node.getClass());\n    i0.ɵɵclassProp(\"tree-node\", true)(\"tree-node-expanded\", ctx_r0.node.isExpanded && ctx_r0.node.hasChildren)(\"tree-node-collapsed\", ctx_r0.node.isCollapsed && ctx_r0.node.hasChildren)(\"tree-node-leaf\", ctx_r0.node.isLeaf)(\"tree-node-active\", ctx_r0.node.isActive)(\"tree-node-focused\", ctx_r0.node.isFocused);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.index === 0);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r0.node)(\"index\", ctx_r0.index)(\"templates\", ctx_r0.templates);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r0.node)(\"templates\", ctx_r0.templates);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"dropIndex\", ctx_r0.node.index + 1)(\"node\", ctx_r0.node.parent);\n} }\nfunction TreeNodeComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_Template, 5, 22, \"div\", 1);\n    i0.ɵɵelementContainer(2, 2);\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.templates.treeNodeFullTemplate);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.templates.treeNodeFullTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(3, _c1, ctx_r0.node, ctx_r0.node, ctx_r0.index, ctx_r0.templates));\n} }\nclass TreeNodeComponent {\n    node;\n    index;\n    templates;\n    /** @nocollapse */ static ɵfac = function TreeNodeComponent_Factory(t) { return new (t || TreeNodeComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeComponent, selectors: [[\"TreeNode\"], [\"tree-node\"]], inputs: { node: \"node\", index: \"index\", templates: \"templates\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [3, \"class\", \"tree-node\", \"tree-node-expanded\", \"tree-node-collapsed\", \"tree-node-leaf\", \"tree-node-active\", \"tree-node-focused\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"node\", \"index\", \"templates\"], [3, \"node\", \"templates\"], [3, \"dropIndex\", \"node\"]], template: function TreeNodeComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeComponent_ng_container_0_Template, 3, 8, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet, TreeNodeChildrenComponent, TreeNodeDropSlot, TreeNodeWrapperComponent, TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeComponent, [{\n        type: Component,\n        args: [{ selector: 'TreeNode, tree-node', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div\n        *ngIf=\"!templates.treeNodeFullTemplate\"\n        [class]=\"node.getClass()\"\n        [class.tree-node]=\"true\"\n        [class.tree-node-expanded]=\"node.isExpanded && node.hasChildren\"\n        [class.tree-node-collapsed]=\"node.isCollapsed && node.hasChildren\"\n        [class.tree-node-leaf]=\"node.isLeaf\"\n        [class.tree-node-active]=\"node.isActive\"\n        [class.tree-node-focused]=\"node.isFocused\"\n      >\n        <tree-node-drop-slot\n          *ngIf=\"index === 0\"\n          [dropIndex]=\"node.index\"\n          [node]=\"node.parent\"\n        ></tree-node-drop-slot>\n\n        <tree-node-wrapper\n          [node]=\"node\"\n          [index]=\"index\"\n          [templates]=\"templates\"\n        ></tree-node-wrapper>\n\n        <tree-node-children\n          [node]=\"node\"\n          [templates]=\"templates\"\n        ></tree-node-children>\n        <tree-node-drop-slot\n          [dropIndex]=\"node.index + 1\"\n          [node]=\"node.parent\"\n        ></tree-node-drop-slot>\n      </div>\n      <ng-container\n        [ngTemplateOutlet]=\"templates.treeNodeFullTemplate\"\n        [ngTemplateOutletContext]=\"{\n          $implicit: node,\n          node: node,\n          index: index,\n          templates: templates\n        }\"\n      >\n      </ng-container>\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], index: [{\n            type: Input\n        }], templates: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeComponent, { className: \"TreeNodeComponent\" }); })();","originalLength":9642,"removedExports":[],"renderedExports":["TreeNodeComponent"],"renderedLength":5287},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/lib/angular-tree-component.module.mjs":{"code":"class TreeModule {\n    /** @nocollapse */ static ɵfac = function TreeModule_Factory(t) { return new (t || TreeModule)(); };\n    /** @nocollapse */ static ɵmod = /** @pureOrBreakMyCode */ i0.ɵɵdefineNgModule({ type: TreeModule });\n    /** @nocollapse */ static ɵinj = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjector({ imports: [CommonModule] });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    TreeComponent,\n                    TreeNodeComponent,\n                    TreeNodeContent,\n                    LoadingComponent,\n                    TreeDropDirective,\n                    TreeDragDirective,\n                    TreeNodeExpanderComponent,\n                    TreeNodeChildrenComponent,\n                    TreeNodeDropSlot,\n                    TreeNodeCollectionComponent,\n                    TreeViewportComponent,\n                    TreeNodeWrapperComponent,\n                    TreeNodeCheckboxComponent,\n                    TreeAnimateOpenDirective,\n                    TreeMobxAutorunDirective\n                ],\n                exports: [\n                    TreeComponent,\n                    TreeNodeComponent,\n                    TreeNodeContent,\n                    LoadingComponent,\n                    TreeDropDirective,\n                    TreeDragDirective,\n                    TreeNodeExpanderComponent,\n                    TreeNodeChildrenComponent,\n                    TreeNodeDropSlot,\n                    TreeNodeCollectionComponent,\n                    TreeViewportComponent,\n                    TreeNodeWrapperComponent,\n                    TreeNodeCheckboxComponent,\n                    TreeAnimateOpenDirective,\n                    TreeMobxAutorunDirective\n                ],\n                imports: [CommonModule],\n                providers: []\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(TreeModule, { declarations: [TreeComponent,\n        TreeNodeComponent,\n        TreeNodeContent,\n        LoadingComponent,\n        TreeDropDirective,\n        TreeDragDirective,\n        TreeNodeExpanderComponent,\n        TreeNodeChildrenComponent,\n        TreeNodeDropSlot,\n        TreeNodeCollectionComponent,\n        TreeViewportComponent,\n        TreeNodeWrapperComponent,\n        TreeNodeCheckboxComponent,\n        TreeAnimateOpenDirective,\n        TreeMobxAutorunDirective], imports: [CommonModule], exports: [TreeComponent,\n        TreeNodeComponent,\n        TreeNodeContent,\n        LoadingComponent,\n        TreeDropDirective,\n        TreeDragDirective,\n        TreeNodeExpanderComponent,\n        TreeNodeChildrenComponent,\n        TreeNodeDropSlot,\n        TreeNodeCollectionComponent,\n        TreeViewportComponent,\n        TreeNodeWrapperComponent,\n        TreeNodeCheckboxComponent,\n        TreeAnimateOpenDirective,\n        TreeMobxAutorunDirective] }); })();\ni0.ɵɵsetComponentScope(TreeNodeCollectionComponent, [i1.NgForOf, TreeNodeComponent,\n    TreeMobxAutorunDirective], []);","originalLength":13090,"removedExports":[],"renderedExports":["TreeModule","TreeModel","TreeNode","TreeDraggedElement","TreeVirtualScroll","TREE_ACTIONS","KEYS","LoadingComponent","TreeAnimateOpenDirective","TreeComponent","TreeNodeComponent","TreeNodeWrapperComponent","TreeNodeContent","TreeDropDirective","TreeDragDirective","TreeNodeExpanderComponent","TreeNodeChildrenComponent","TreeNodeDropSlot","TreeNodeCollectionComponent","TreeViewportComponent","TreeNodeCheckboxComponent"],"renderedLength":3140},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of angular-tree-component\n */","originalLength":766,"removedExports":[],"renderedExports":[],"renderedLength":54},"/Users/avanisaxena/Documents/angular-tree-component/dist/angular-tree-component/esm2022/circlon-angular-tree-component.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":564,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, Injectable, Component, ViewEncapsulation, EventEmitter, Output, HostListener, ContentChild, ViewChild, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { autorun, reaction, computed as computed$1, observable as observable$1, action as action$1 } from 'mobx';\n\nclass TreeMobxAutorunDirective {\n    templateRef;\n    viewContainer;\n    templateBindings = {};\n    dispose;\n    view;\n    treeMobxAutorun;\n    constructor(templateRef, viewContainer) {\n        this.templateRef = templateRef;\n        this.viewContainer = viewContainer;\n    }\n    ngOnInit() {\n        this.view = this.viewContainer.createEmbeddedView(this.templateRef);\n        if (this.dispose) {\n            this.dispose();\n        }\n        if (this.shouldDetach()) {\n            this.view.detach();\n        }\n        this.autoDetect(this.view);\n    }\n    shouldDetach() {\n        return this.treeMobxAutorun && this.treeMobxAutorun.detach;\n    }\n    autoDetect(view) {\n        this.dispose = autorun(() => view.detectChanges());\n    }\n    ngOnDestroy() {\n        if (this.dispose) {\n            this.dispose();\n        }\n    }\n    /** @nocollapse */ static ɵfac = function TreeMobxAutorunDirective_Factory(t) { return new (t || TreeMobxAutorunDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeMobxAutorunDirective, selectors: [[\"\", \"treeMobxAutorun\", \"\"]], inputs: { treeMobxAutorun: \"treeMobxAutorun\" } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeMobxAutorunDirective, [{\n        type: Directive,\n        args: [{ selector: '[treeMobxAutorun]' }]\n    }], () => [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }], { treeMobxAutorun: [{\n            type: Input\n        }] }); })();\n\nconst KEYS = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    ENTER: 13,\n    SPACE: 32,\n    CONTEXT_MENU: 32\n};\n\nconst TREE_ACTIONS = {\n    TOGGLE_ACTIVE: (tree, node, $event) => node && node.toggleActivated(),\n    TOGGLE_ACTIVE_MULTI: (tree, node, $event) => node && node.toggleActivated(true),\n    TOGGLE_SELECTED: (tree, node, $event) => node && node.toggleSelected(),\n    ACTIVATE: (tree, node, $event) => node.setIsActive(true),\n    DEACTIVATE: (tree, node, $event) => node.setIsActive(false),\n    SELECT: (tree, node, $event) => node.setIsSelected(true),\n    DESELECT: (tree, node, $event) => node.setIsSelected(false),\n    FOCUS: (tree, node, $event) => node.focus(),\n    TOGGLE_EXPANDED: (tree, node, $event) => node.hasChildren && node.toggleExpanded(),\n    EXPAND: (tree, node, $event) => node.expand(),\n    COLLAPSE: (tree, node, $event) => node.collapse(),\n    DRILL_DOWN: (tree, node, $event) => tree.focusDrillDown(),\n    DRILL_UP: (tree, node, $event) => tree.focusDrillUp(),\n    NEXT_NODE: (tree, node, $event) => tree.focusNextNode(),\n    PREVIOUS_NODE: (tree, node, $event) => tree.focusPreviousNode(),\n    MOVE_NODE: (tree, node, $event, { from, to }) => {\n        // default action assumes from = node, to = {parent, index}\n        if ($event.ctrlKey) {\n            tree.copyNode(from, to);\n        }\n        else {\n            tree.moveNode(from, to);\n        }\n    }\n};\nconst defaultActionMapping = {\n    mouse: {\n        click: TREE_ACTIONS.TOGGLE_ACTIVE,\n        dblClick: null,\n        contextMenu: null,\n        expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,\n        checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,\n        drop: TREE_ACTIONS.MOVE_NODE\n    },\n    keys: {\n        [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\n        [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\n        [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\n        [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\n        [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\n        [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\n    }\n};\nclass TreeOptions {\n    options;\n    get hasChildrenField() { return this.options.hasChildrenField || 'hasChildren'; }\n    get childrenField() { return this.options.childrenField || 'children'; }\n    get displayField() { return this.options.displayField || 'name'; }\n    get idField() { return this.options.idField || 'id'; }\n    get isExpandedField() { return this.options.isExpandedField || 'isExpanded'; }\n    get getChildren() { return this.options.getChildren; }\n    get levelPadding() { return this.options.levelPadding || 0; }\n    get useVirtualScroll() { return this.options.useVirtualScroll; }\n    get animateExpand() { return this.options.animateExpand; }\n    get animateSpeed() { return this.options.animateSpeed || 1; }\n    get animateAcceleration() { return this.options.animateAcceleration || 1.2; }\n    get scrollOnActivate() { return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate; }\n    get rtl() { return !!this.options.rtl; }\n    get rootId() { return this.options.rootId; }\n    get useCheckbox() { return this.options.useCheckbox; }\n    get useTriState() { return this.options.useTriState === undefined ? true : this.options.useTriState; }\n    get scrollContainer() { return this.options.scrollContainer; }\n    get allowDragoverStyling() { return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling; }\n    actionMapping;\n    constructor(options = {}) {\n        this.options = options;\n        this.actionMapping = {\n            mouse: {\n                click: this.options?.actionMapping?.mouse?.click ?? defaultActionMapping.mouse.click,\n                dblClick: this.options?.actionMapping?.mouse?.dblClick ?? defaultActionMapping.mouse.dblClick,\n                contextMenu: this.options?.actionMapping?.mouse?.contextMenu ?? defaultActionMapping.mouse.contextMenu,\n                expanderClick: this.options?.actionMapping?.mouse?.expanderClick ?? defaultActionMapping.mouse.expanderClick,\n                checkboxClick: this.options?.actionMapping?.mouse?.checkboxClick ?? defaultActionMapping.mouse.checkboxClick,\n                drop: this.options?.actionMapping?.mouse?.drop ?? defaultActionMapping.mouse.drop,\n                dragStart: this.options?.actionMapping?.mouse?.dragStart ?? undefined,\n                drag: this.options?.actionMapping?.mouse?.drag ?? undefined,\n                dragEnd: this.options?.actionMapping?.mouse?.dragEnd ?? undefined,\n                dragOver: this.options?.actionMapping?.mouse?.dragOver ?? undefined,\n                dragLeave: this.options?.actionMapping?.mouse?.dragLeave ?? undefined,\n                dragEnter: this.options?.actionMapping?.mouse?.dragEnter ?? undefined,\n                mouseOver: this.options?.actionMapping?.mouse?.mouseOver ?? undefined,\n                mouseOut: this.options?.actionMapping?.mouse?.mouseOut ?? undefined,\n            },\n            keys: {\n                [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\n                [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\n                [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\n                [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\n                [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\n                [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\n            }\n        };\n        if (this.options?.actionMapping?.keys) {\n            this.actionMapping.keys = {\n                ...this.actionMapping.keys,\n                ...this.options.actionMapping.keys\n            };\n        }\n        if (options.rtl) {\n            this.actionMapping.keys[KEYS.RIGHT] = options.actionMapping?.keys[KEYS.RIGHT] || TREE_ACTIONS.DRILL_UP;\n            this.actionMapping.keys[KEYS.LEFT] = options.actionMapping?.keys[KEYS.LEFT] || TREE_ACTIONS.DRILL_DOWN;\n        }\n    }\n    getNodeClone(node) {\n        if (this.options.getNodeClone) {\n            return this.options.getNodeClone(node);\n        }\n        // remove id from clone\n        // keeping ie11 compatibility\n        const nodeClone = Object.assign({}, node.data);\n        if (nodeClone.id) {\n            delete nodeClone.id;\n        }\n        return nodeClone;\n    }\n    allowDrop(element, to, $event) {\n        if (this.options.allowDrop instanceof Function) {\n            return this.options.allowDrop(element, to, $event);\n        }\n        else {\n            return this.options.allowDrop === undefined ? true : this.options.allowDrop;\n        }\n    }\n    allowDrag(node) {\n        if (this.options.allowDrag instanceof Function) {\n            return this.options.allowDrag(node);\n        }\n        else {\n            return this.options.allowDrag;\n        }\n    }\n    nodeClass(node) {\n        return this.options.nodeClass ? this.options.nodeClass(node) : '';\n    }\n    nodeHeight(node) {\n        if (node.data.virtual) {\n            return 0;\n        }\n        let nodeHeight = this.options.nodeHeight || 22;\n        if (typeof nodeHeight === 'function') {\n            nodeHeight = nodeHeight(node);\n        }\n        // account for drop slots:\n        return nodeHeight + (node.index === 0 ? 2 : 1) * this.dropSlotHeight;\n    }\n    get dropSlotHeight() {\n        return typeof this.options.dropSlotHeight === 'number' ? this.options.dropSlotHeight : 2;\n    }\n}\n\nconst TREE_EVENTS = {\n    toggleExpanded: 'toggleExpanded',\n    activate: 'activate',\n    deactivate: 'deactivate',\n    nodeActivate: 'nodeActivate',\n    nodeDeactivate: 'nodeDeactivate',\n    select: 'select',\n    deselect: 'deselect',\n    focus: 'focus',\n    blur: 'blur',\n    initialized: 'initialized',\n    updateData: 'updateData',\n    moveNode: 'moveNode',\n    copyNode: 'copyNode',\n    event: 'event',\n    loadNodeChildren: 'loadNodeChildren',\n    changeFilter: 'changeFilter',\n    stateChange: 'stateChange'\n};\n\nvar __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$3 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nclass TreeNode {\n    data;\n    parent;\n    treeModel;\n    handler;\n    get isHidden() { return this.treeModel.isHidden(this); }\n    ;\n    get isExpanded() { return this.treeModel.isExpanded(this); }\n    ;\n    get isActive() { return this.treeModel.isActive(this); }\n    ;\n    get isFocused() { return this.treeModel.isNodeFocused(this); }\n    ;\n    get isSelected() {\n        if (this.isSelectable()) {\n            return this.treeModel.isSelected(this);\n        }\n        else {\n            return this.children.some((node) => node.isSelected);\n        }\n    }\n    ;\n    get isAllSelected() {\n        if (this.isSelectable()) {\n            return this.treeModel.isSelected(this);\n        }\n        else {\n            return this.children.every((node) => node.isAllSelected);\n        }\n    }\n    ;\n    get isPartiallySelected() {\n        return this.isSelected && !this.isAllSelected;\n    }\n    children;\n    index;\n    position = 0;\n    height;\n    get level() {\n        return this.parent ? this.parent.level + 1 : 0;\n    }\n    get path() {\n        return this.parent ? [...this.parent.path, this.id] : [];\n    }\n    get elementRef() {\n        throw `Element Ref is no longer supported since introducing virtual scroll\\n\n      You may use a template to obtain a reference to the element`;\n    }\n    _originalNode;\n    get originalNode() { return this._originalNode; }\n    ;\n    constructor(data, parent, treeModel, index) {\n        this.data = data;\n        this.parent = parent;\n        this.treeModel = treeModel;\n        if (this.id === undefined || this.id === null) {\n            this.id = uuid();\n        } // Make sure there's a unique id without overriding existing ids to work with immutable data structures\n        this.index = index;\n        if (this.getField('children')) {\n            this._initChildren();\n        }\n        this.autoLoadChildren();\n    }\n    // helper get functions:\n    get hasChildren() {\n        return !!(this.getField('hasChildren') || (this.children && this.children.length > 0));\n    }\n    get isCollapsed() { return !this.isExpanded; }\n    get isLeaf() { return !this.hasChildren; }\n    get isRoot() { return this.parent.data.virtual; }\n    get realParent() { return this.isRoot ? null : this.parent; }\n    // proxy functions:\n    get options() { return this.treeModel.options; }\n    fireEvent(event) { this.treeModel.fireEvent(event); }\n    // field accessors:\n    get displayField() {\n        return this.getField('display');\n    }\n    get id() {\n        return this.getField('id');\n    }\n    set id(value) {\n        this.setField('id', value);\n    }\n    getField(key) {\n        return this.data[this.options[`${key}Field`]];\n    }\n    setField(key, value) {\n        this.data[this.options[`${key}Field`]] = value;\n    }\n    // traversing:\n    _findAdjacentSibling(steps, skipHidden = false) {\n        const siblings = this._getParentsChildren(skipHidden);\n        const index = siblings.indexOf(this);\n        return siblings.length > index + steps ? siblings[index + steps] : null;\n    }\n    findNextSibling(skipHidden = false) {\n        return this._findAdjacentSibling(+1, skipHidden);\n    }\n    findPreviousSibling(skipHidden = false) {\n        return this._findAdjacentSibling(-1, skipHidden);\n    }\n    getVisibleChildren() {\n        return this.visibleChildren;\n    }\n    get visibleChildren() {\n        return (this.children || []).filter((node) => !node.isHidden);\n    }\n    getFirstChild(skipHidden = false) {\n        let children = skipHidden ? this.visibleChildren : this.children;\n        return children != null && children.length ? children[0] : null;\n    }\n    getLastChild(skipHidden = false) {\n        let children = skipHidden ? this.visibleChildren : this.children;\n        return children != null && children.length ? children[children.length - 1] : null;\n    }\n    findNextNode(goInside = true, skipHidden = false) {\n        return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||\n            this.findNextSibling(skipHidden) ||\n            this.parent && this.parent.findNextNode(false, skipHidden);\n    }\n    findPreviousNode(skipHidden = false) {\n        let previousSibling = this.findPreviousSibling(skipHidden);\n        if (!previousSibling) {\n            return this.realParent;\n        }\n        return previousSibling._getLastOpenDescendant(skipHidden);\n    }\n    _getLastOpenDescendant(skipHidden = false) {\n        const lastChild = this.getLastChild(skipHidden);\n        return (this.isCollapsed || !lastChild)\n            ? this\n            : lastChild._getLastOpenDescendant(skipHidden);\n    }\n    _getParentsChildren(skipHidden = false) {\n        const children = this.parent &&\n            (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);\n        return children || [];\n    }\n    getIndexInParent(skipHidden = false) {\n        return this._getParentsChildren(skipHidden).indexOf(this);\n    }\n    isDescendantOf(node) {\n        if (this === node)\n            return true;\n        else\n            return this.parent && this.parent.isDescendantOf(node);\n    }\n    getNodePadding() {\n        return this.options.levelPadding * (this.level - 1) + 'px';\n    }\n    getClass() {\n        return [this.options.nodeClass(this), `tree-node-level-${this.level}`].join(' ');\n    }\n    onDrop($event) {\n        this.mouseAction('drop', $event.event, {\n            from: $event.element,\n            to: { parent: this, index: 0, dropOnNode: true }\n        });\n    }\n    allowDrop = (element, $event) => {\n        return this.options.allowDrop(element, { parent: this, index: 0 }, $event);\n    };\n    allowDragoverStyling = () => {\n        return this.options.allowDragoverStyling;\n    };\n    allowDrag() {\n        return this.options.allowDrag(this);\n    }\n    // helper methods:\n    loadNodeChildren() {\n        if (!this.options.getChildren) {\n            return Promise.resolve(); // Not getChildren method - for using redux\n        }\n        return Promise.resolve(this.options.getChildren(this))\n            .then((children) => {\n            if (children) {\n                this.setField('children', children);\n                this._initChildren();\n                if (this.options.useTriState && this.treeModel.isSelected(this)) {\n                    this.setIsSelected(true);\n                }\n                this.children.forEach((child) => {\n                    if (child.getField('isExpanded') && child.hasChildren) {\n                        child.expand();\n                    }\n                });\n            }\n        }).then(() => {\n            this.fireEvent({\n                eventName: TREE_EVENTS.loadNodeChildren,\n                node: this\n            });\n        });\n    }\n    expand() {\n        if (!this.isExpanded) {\n            this.toggleExpanded();\n        }\n        return this;\n    }\n    collapse() {\n        if (this.isExpanded) {\n            this.toggleExpanded();\n        }\n        return this;\n    }\n    doForAll(fn) {\n        Promise.resolve(fn(this)).then(() => {\n            if (this.children) {\n                this.children.forEach((child) => child.doForAll(fn));\n            }\n        });\n    }\n    expandAll() {\n        this.doForAll((node) => node.expand());\n    }\n    collapseAll() {\n        this.doForAll((node) => node.collapse());\n    }\n    ensureVisible() {\n        if (this.realParent) {\n            this.realParent.expand();\n            this.realParent.ensureVisible();\n        }\n        return this;\n    }\n    toggleExpanded() {\n        this.setIsExpanded(!this.isExpanded);\n        return this;\n    }\n    setIsExpanded(value) {\n        if (this.hasChildren) {\n            this.treeModel.setExpandedNode(this, value);\n        }\n        return this;\n    }\n    ;\n    autoLoadChildren() {\n        this.handler =\n            reaction(() => this.isExpanded, (isExpanded) => {\n                if (!this.children && this.hasChildren && isExpanded) {\n                    this.loadNodeChildren();\n                }\n            }, { fireImmediately: true });\n    }\n    dispose() {\n        if (this.children) {\n            this.children.forEach((child) => child.dispose());\n        }\n        if (this.handler) {\n            this.handler();\n        }\n        this.parent = null;\n        this.children = null;\n    }\n    setIsActive(value, multi = false) {\n        this.treeModel.setActiveNode(this, value, multi);\n        if (value) {\n            this.focus(this.options.scrollOnActivate);\n        }\n        return this;\n    }\n    isSelectable() {\n        return this.isLeaf || !this.children || !this.options.useTriState;\n    }\n    setIsSelected(value) {\n        if (this.isSelectable()) {\n            this.treeModel.setSelectedNode(this, value);\n        }\n        else {\n            this.visibleChildren.forEach((child) => child.setIsSelected(value));\n        }\n        return this;\n    }\n    toggleSelected() {\n        this.setIsSelected(!this.isSelected);\n        return this;\n    }\n    toggleActivated(multi = false) {\n        this.setIsActive(!this.isActive, multi);\n        return this;\n    }\n    setActiveAndVisible(multi = false) {\n        this.setIsActive(true, multi)\n            .ensureVisible();\n        setTimeout(this.scrollIntoView.bind(this));\n        return this;\n    }\n    scrollIntoView(force = false) {\n        this.treeModel.virtualScroll.scrollIntoView(this, force);\n    }\n    focus(scroll = true) {\n        let previousNode = this.treeModel.getFocusedNode();\n        this.treeModel.setFocusedNode(this);\n        if (scroll) {\n            this.scrollIntoView();\n        }\n        if (previousNode) {\n            this.fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });\n        }\n        this.fireEvent({ eventName: TREE_EVENTS.focus, node: this });\n        return this;\n    }\n    blur() {\n        let previousNode = this.treeModel.getFocusedNode();\n        this.treeModel.setFocusedNode(null);\n        if (previousNode) {\n            this.fireEvent({ eventName: TREE_EVENTS.blur, node: this });\n        }\n        return this;\n    }\n    setIsHidden(value) {\n        this.treeModel.setIsHidden(this, value);\n    }\n    hide() {\n        this.setIsHidden(true);\n    }\n    show() {\n        this.setIsHidden(false);\n    }\n    mouseAction(actionName, $event, data = null) {\n        this.treeModel.setFocus(true);\n        const actionMapping = this.options.actionMapping.mouse;\n        const mouseAction = actionMapping[actionName];\n        if (mouseAction) {\n            mouseAction(this.treeModel, this, $event, data);\n        }\n    }\n    getSelfHeight() {\n        return this.options.nodeHeight(this);\n    }\n    _initChildren() {\n        this.children = this.getField('children')\n            .map((c, index) => new TreeNode(c, this, this.treeModel, index));\n    }\n}\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isHidden\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isExpanded\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isActive\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isFocused\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isSelected\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isAllSelected\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"isPartiallySelected\", null);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Array)\n], TreeNode.prototype, \"children\", void 0);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Number)\n], TreeNode.prototype, \"index\", void 0);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Object)\n], TreeNode.prototype, \"position\", void 0);\n__decorate$3([\n    observable$1,\n    __metadata$3(\"design:type\", Number)\n], TreeNode.prototype, \"height\", void 0);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Number),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"level\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Array),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"path\", null);\n__decorate$3([\n    computed$1,\n    __metadata$3(\"design:type\", Object),\n    __metadata$3(\"design:paramtypes\", [])\n], TreeNode.prototype, \"visibleChildren\", null);\n__decorate$3([\n    action$1,\n    __metadata$3(\"design:type\", Function),\n    __metadata$3(\"design:paramtypes\", [Object]),\n    __metadata$3(\"design:returntype\", void 0)\n], TreeNode.prototype, \"setIsSelected\", null);\n__decorate$3([\n    action$1,\n    __metadata$3(\"design:type\", Function),\n    __metadata$3(\"design:paramtypes\", []),\n    __metadata$3(\"design:returntype\", void 0)\n], TreeNode.prototype, \"_initChildren\", null);\nfunction uuid() {\n    return Math.floor(Math.random() * 10000000000000);\n}\n\nvar __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$2 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nclass TreeModel {\n    static focusedTree = null;\n    options = new TreeOptions();\n    nodes;\n    eventNames = Object.keys(TREE_EVENTS);\n    virtualScroll;\n    roots;\n    expandedNodeIds = {};\n    selectedLeafNodeIds = {};\n    activeNodeIds = {};\n    hiddenNodeIds = {};\n    focusedNodeId = null;\n    virtualRoot;\n    firstUpdate = true;\n    events;\n    subscriptions = [];\n    // events\n    fireEvent(event) {\n        event.treeModel = this;\n        this.events[event.eventName].emit(event);\n        this.events.event.emit(event);\n    }\n    subscribe(eventName, fn) {\n        const subscription = this.events[eventName].subscribe(fn);\n        this.subscriptions.push(subscription);\n    }\n    // getters\n    getFocusedNode() {\n        return this.focusedNode;\n    }\n    getActiveNode() {\n        return this.activeNodes[0];\n    }\n    getActiveNodes() {\n        return this.activeNodes;\n    }\n    getVisibleRoots() {\n        return this.virtualRoot.visibleChildren;\n    }\n    getFirstRoot(skipHidden = false) {\n        const root = skipHidden ? this.getVisibleRoots() : this.roots;\n        return root != null && root.length ? root[0] : null;\n    }\n    getLastRoot(skipHidden = false) {\n        const root = skipHidden ? this.getVisibleRoots() : this.roots;\n        return root != null && root.length ? root[root.length - 1] : null;\n    }\n    get isFocused() {\n        return TreeModel.focusedTree === this;\n    }\n    isNodeFocused(node) {\n        return this.focusedNode === node;\n    }\n    isEmptyTree() {\n        return this.roots && this.roots.length === 0;\n    }\n    get focusedNode() {\n        return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;\n    }\n    get expandedNodes() {\n        const nodes = Object.keys(this.expandedNodeIds)\n            .filter((id) => this.expandedNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    get activeNodes() {\n        const nodes = Object.keys(this.activeNodeIds)\n            .filter((id) => this.activeNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    get hiddenNodes() {\n        const nodes = Object.keys(this.hiddenNodeIds)\n            .filter((id) => this.hiddenNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    get selectedLeafNodes() {\n        const nodes = Object.keys(this.selectedLeafNodeIds)\n            .filter((id) => this.selectedLeafNodeIds[id])\n            .map((id) => this.getNodeById(id));\n        return nodes.filter(Boolean);\n    }\n    // locating nodes\n    getNodeByPath(path, startNode = null) {\n        if (!path)\n            return null;\n        startNode = startNode || this.virtualRoot;\n        if (path.length === 0)\n            return startNode;\n        if (!startNode.children)\n            return null;\n        const childId = path.shift();\n        const childNode = startNode.children.find(c => c.id === childId);\n        if (!childNode)\n            return null;\n        return this.getNodeByPath(path, childNode);\n    }\n    getNodeById(id) {\n        const idStr = id.toString();\n        return this.getNodeBy((node) => node.id.toString() === idStr);\n    }\n    getNodeBy(predicate, startNode = null) {\n        startNode = startNode || this.virtualRoot;\n        if (!startNode.children)\n            return null;\n        const found = startNode.children.find(predicate);\n        if (found) { // found in children\n            return found;\n        }\n        else { // look in children's children\n            for (let child of startNode.children) {\n                const foundInChildren = this.getNodeBy(predicate, child);\n                if (foundInChildren)\n                    return foundInChildren;\n            }\n        }\n    }\n    isExpanded(node) {\n        return this.expandedNodeIds[node.id];\n    }\n    isHidden(node) {\n        return this.hiddenNodeIds[node.id];\n    }\n    isActive(node) {\n        return this.activeNodeIds[node.id];\n    }\n    isSelected(node) {\n        return this.selectedLeafNodeIds[node.id];\n    }\n    ngOnDestroy() {\n        this.dispose();\n        this.unsubscribeAll();\n    }\n    dispose() {\n        // Dispose reactions of the replaced nodes\n        if (this.virtualRoot) {\n            this.virtualRoot.dispose();\n        }\n    }\n    unsubscribeAll() {\n        this.subscriptions.forEach(subscription => subscription.unsubscribe());\n        this.subscriptions = [];\n    }\n    // actions\n    setData({ nodes, options = null, events = null }) {\n        if (options) {\n            this.options = new TreeOptions(options);\n        }\n        if (events) {\n            this.events = events;\n        }\n        if (nodes) {\n            this.nodes = nodes;\n        }\n        this.update();\n    }\n    update() {\n        // Rebuild tree:\n        let virtualRootConfig = {\n            id: this.options.rootId,\n            virtual: true,\n            [this.options.childrenField]: this.nodes\n        };\n        this.dispose();\n        this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);\n        this.roots = this.virtualRoot.children;\n        // Fire event:\n        if (this.firstUpdate) {\n            if (this.roots) {\n                this.firstUpdate = false;\n                this._calculateExpandedNodes();\n            }\n        }\n        else {\n            this.fireEvent({ eventName: TREE_EVENTS.updateData });\n        }\n    }\n    setFocusedNode(node) {\n        this.focusedNodeId = node ? node.id : null;\n    }\n    setFocus(value) {\n        TreeModel.focusedTree = value ? this : null;\n    }\n    doForAll(fn) {\n        this.roots.forEach((root) => root.doForAll(fn));\n    }\n    focusNextNode() {\n        let previousNode = this.getFocusedNode();\n        let nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);\n        if (nextNode)\n            nextNode.focus();\n    }\n    focusPreviousNode() {\n        let previousNode = this.getFocusedNode();\n        let nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);\n        if (nextNode)\n            nextNode.focus();\n    }\n    focusDrillDown() {\n        let previousNode = this.getFocusedNode();\n        if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {\n            previousNode.toggleExpanded();\n        }\n        else {\n            let nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);\n            if (nextNode)\n                nextNode.focus();\n        }\n    }\n    focusDrillUp() {\n        let previousNode = this.getFocusedNode();\n        if (!previousNode)\n            return;\n        if (previousNode.isExpanded) {\n            previousNode.toggleExpanded();\n        }\n        else {\n            let nextNode = previousNode.realParent;\n            if (nextNode)\n                nextNode.focus();\n        }\n    }\n    setActiveNode(node, value, multi = false) {\n        if (multi) {\n            this._setActiveNodeMulti(node, value);\n        }\n        else {\n            this._setActiveNodeSingle(node, value);\n        }\n        if (value) {\n            node.focus(this.options.scrollOnActivate);\n            this.fireEvent({ eventName: TREE_EVENTS.activate, node });\n            this.fireEvent({ eventName: TREE_EVENTS.nodeActivate, node }); // For IE11\n        }\n        else {\n            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node });\n            this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node }); // For IE11\n        }\n    }\n    setSelectedNode(node, value) {\n        this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, { [node.id]: value });\n        if (value) {\n            node.focus();\n            this.fireEvent({ eventName: TREE_EVENTS.select, node });\n        }\n        else {\n            this.fireEvent({ eventName: TREE_EVENTS.deselect, node });\n        }\n    }\n    setExpandedNode(node, value) {\n        this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, { [node.id]: value });\n        this.fireEvent({ eventName: TREE_EVENTS.toggleExpanded, node, isExpanded: value });\n    }\n    expandAll() {\n        this.roots.forEach((root) => root.expandAll());\n    }\n    collapseAll() {\n        this.roots.forEach((root) => root.collapseAll());\n    }\n    setIsHidden(node, value) {\n        this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, { [node.id]: value });\n    }\n    setHiddenNodeIds(nodeIds) {\n        this.hiddenNodeIds = nodeIds.reduce((hiddenNodeIds, id) => Object.assign(hiddenNodeIds, {\n            [id]: true\n        }), {});\n    }\n    performKeyAction(node, $event) {\n        const keyAction = this.options.actionMapping.keys[$event.keyCode];\n        if (keyAction) {\n            $event.preventDefault();\n            keyAction(this, node, $event);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    filterNodes(filter, autoShow = true) {\n        let filterFn;\n        if (!filter) {\n            return this.clearFilter();\n        }\n        // support function and string filter\n        if (filter && typeof filter.valueOf() === 'string') {\n            filterFn = (node) => node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1;\n        }\n        else if (filter && typeof filter === 'function') {\n            filterFn = filter;\n        }\n        else {\n            console.error('Don\\'t know what to do with filter', filter);\n            console.error('Should be either a string or function');\n            return;\n        }\n        const ids = {};\n        this.roots.forEach((node) => this._filterNode(ids, node, filterFn, autoShow));\n        this.hiddenNodeIds = ids;\n        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });\n    }\n    clearFilter() {\n        this.hiddenNodeIds = {};\n        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });\n    }\n    moveNode(node, to) {\n        const fromIndex = node.getIndexInParent();\n        const fromParent = node.parent;\n        if (!this.canMoveNode(node, to, fromIndex))\n            return;\n        const fromChildren = fromParent.getField('children');\n        // If node doesn't have children - create children array\n        if (!to.parent.getField('children')) {\n            to.parent.setField('children', []);\n        }\n        const toChildren = to.parent.getField('children');\n        const originalNode = fromChildren.splice(fromIndex, 1)[0];\n        // Compensate for index if already removed from parent:\n        let toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;\n        toChildren.splice(toIndex, 0, originalNode);\n        fromParent.treeModel.update();\n        if (to.parent.treeModel !== fromParent.treeModel) {\n            to.parent.treeModel.update();\n        }\n        this.fireEvent({\n            eventName: TREE_EVENTS.moveNode,\n            node: originalNode,\n            to: { parent: to.parent.data, index: toIndex },\n            from: { parent: fromParent.data, index: fromIndex }\n        });\n    }\n    copyNode(node, to) {\n        const fromIndex = node.getIndexInParent();\n        if (!this.canMoveNode(node, to, fromIndex))\n            return;\n        // If node doesn't have children - create children array\n        if (!to.parent.getField('children')) {\n            to.parent.setField('children', []);\n        }\n        const toChildren = to.parent.getField('children');\n        const nodeCopy = this.options.getNodeClone(node);\n        toChildren.splice(to.index, 0, nodeCopy);\n        node.treeModel.update();\n        if (to.parent.treeModel !== node.treeModel) {\n            to.parent.treeModel.update();\n        }\n        this.fireEvent({ eventName: TREE_EVENTS.copyNode, node: nodeCopy, to: { parent: to.parent.data, index: to.index } });\n    }\n    getState() {\n        return {\n            expandedNodeIds: this.expandedNodeIds,\n            selectedLeafNodeIds: this.selectedLeafNodeIds,\n            activeNodeIds: this.activeNodeIds,\n            hiddenNodeIds: this.hiddenNodeIds,\n            focusedNodeId: this.focusedNodeId\n        };\n    }\n    setState(state) {\n        if (!state)\n            return;\n        Object.assign(this, {\n            expandedNodeIds: state.expandedNodeIds || {},\n            selectedLeafNodeIds: state.selectedLeafNodeIds || {},\n            activeNodeIds: state.activeNodeIds || {},\n            hiddenNodeIds: state.hiddenNodeIds || {},\n            focusedNodeId: state.focusedNodeId\n        });\n    }\n    subscribeToState(fn) {\n        autorun(() => fn(this.getState()));\n    }\n    canMoveNode(node, to, fromIndex = undefined) {\n        const fromNodeIndex = fromIndex || node.getIndexInParent();\n        // same node:\n        if (node.parent === to.parent && fromIndex === to.index) {\n            return false;\n        }\n        return !to.parent.isDescendantOf(node);\n    }\n    calculateExpandedNodes() {\n        this._calculateExpandedNodes();\n    }\n    // private methods\n    _filterNode(ids, node, filterFn, autoShow) {\n        // if node passes function then it's visible\n        let isVisible = filterFn(node);\n        if (node.children) {\n            // if one of node's children passes filter then this node is also visible\n            node.children.forEach((child) => {\n                if (this._filterNode(ids, child, filterFn, autoShow)) {\n                    isVisible = true;\n                }\n            });\n        }\n        // mark node as hidden\n        if (!isVisible) {\n            ids[node.id] = true;\n        }\n        // auto expand parents to make sure the filtered nodes are visible\n        if (autoShow && isVisible) {\n            node.ensureVisible();\n        }\n        return isVisible;\n    }\n    _calculateExpandedNodes(startNode = null) {\n        startNode = startNode || this.virtualRoot;\n        if (startNode.data[this.options.isExpandedField]) {\n            this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, { [startNode.id]: true });\n        }\n        if (startNode.children) {\n            startNode.children.forEach((child) => this._calculateExpandedNodes(child));\n        }\n    }\n    _setActiveNodeSingle(node, value) {\n        // Deactivate all other nodes:\n        this.activeNodes\n            .filter((activeNode) => activeNode !== node)\n            .forEach((activeNode) => {\n            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });\n            this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node: activeNode }); // For IE11\n        });\n        if (value) {\n            this.activeNodeIds = { [node.id]: true };\n        }\n        else {\n            this.activeNodeIds = {};\n        }\n    }\n    _setActiveNodeMulti(node, value) {\n        this.activeNodeIds = Object.assign({}, this.activeNodeIds, { [node.id]: value });\n    }\n    /** @nocollapse */ static ɵfac = function TreeModel_Factory(t) { return new (t || TreeModel)(); };\n    /** @nocollapse */ static ɵprov = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjectable({ token: TreeModel, factory: TreeModel.ɵfac });\n}\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Array)\n], TreeModel.prototype, \"roots\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"expandedNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"selectedLeafNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"activeNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"hiddenNodeIds\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", Object)\n], TreeModel.prototype, \"focusedNodeId\", void 0);\n__decorate$2([\n    observable$1,\n    __metadata$2(\"design:type\", TreeNode)\n], TreeModel.prototype, \"virtualRoot\", void 0);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"focusedNode\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"expandedNodes\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"activeNodes\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"hiddenNodes\", null);\n__decorate$2([\n    computed$1,\n    __metadata$2(\"design:type\", Object),\n    __metadata$2(\"design:paramtypes\", [])\n], TreeModel.prototype, \"selectedLeafNodes\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setData\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"update\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setFocusedNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setFocus\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"doForAll\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusNextNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusPreviousNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusDrillDown\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"focusDrillUp\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setActiveNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setSelectedNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setExpandedNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"expandAll\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"collapseAll\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setIsHidden\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setHiddenNodeIds\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"filterNodes\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", []),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"clearFilter\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"moveNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object, Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"copyNode\", null);\n__decorate$2([\n    action$1,\n    __metadata$2(\"design:type\", Function),\n    __metadata$2(\"design:paramtypes\", [Object]),\n    __metadata$2(\"design:returntype\", void 0)\n], TreeModel.prototype, \"setState\", null);\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeModel, [{\n        type: Injectable\n    }], null, { roots: [], expandedNodeIds: [], selectedLeafNodeIds: [], activeNodeIds: [], hiddenNodeIds: [], focusedNodeId: [], virtualRoot: [], focusedNode: [], expandedNodes: [], activeNodes: [], hiddenNodes: [], selectedLeafNodes: [], setData: [], update: [], setFocusedNode: [], setFocus: [], doForAll: [], focusNextNode: [], focusPreviousNode: [], focusDrillDown: [], focusDrillUp: [], setActiveNode: [], setSelectedNode: [], setExpandedNode: [], expandAll: [], collapseAll: [], setIsHidden: [], setHiddenNodeIds: [], filterNodes: [], clearFilter: [], moveNode: [], copyNode: [], setState: [] }); })();\n\nclass TreeDraggedElement {\n    _draggedElement = null;\n    set(draggedElement) {\n        this._draggedElement = draggedElement;\n    }\n    get() {\n        return this._draggedElement;\n    }\n    isDragging() {\n        return !!this.get();\n    }\n    /** @nocollapse */ static ɵfac = function TreeDraggedElement_Factory(t) { return new (t || TreeDraggedElement)(); };\n    /** @nocollapse */ static ɵprov = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjectable({ token: TreeDraggedElement, factory: TreeDraggedElement.ɵfac, providedIn: 'root' });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeDraggedElement, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], null, null); })();\n\nvar __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$1 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\nconst Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\nclass TreeVirtualScroll {\n    treeModel;\n    _dispose;\n    yBlocks = 0;\n    x = 0;\n    viewportHeight = null;\n    viewport = null;\n    get y() {\n        return this.yBlocks * Y_EPSILON;\n    }\n    get totalHeight() {\n        return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\n    }\n    constructor(treeModel) {\n        this.treeModel = treeModel;\n        treeModel.virtualScroll = this;\n        this._dispose = [autorun(() => this.fixScroll())];\n    }\n    fireEvent(event) {\n        this.treeModel.fireEvent(event);\n    }\n    init() {\n        const fn = this.recalcPositions.bind(this);\n        fn();\n        this._dispose = [\n            ...this._dispose,\n            reaction(() => this.treeModel.roots, fn),\n            reaction(() => this.treeModel.expandedNodeIds, fn),\n            reaction(() => this.treeModel.hiddenNodeIds, fn)\n        ];\n        this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\n    }\n    isEnabled() {\n        return this.treeModel.options.useVirtualScroll;\n    }\n    _setYBlocks(value) {\n        this.yBlocks = value;\n    }\n    recalcPositions() {\n        this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\n    }\n    _getPositionAfter(nodes, startPos) {\n        let position = startPos;\n        nodes.forEach((node) => {\n            node.position = position;\n            position = this._getPositionAfterNode(node, position);\n        });\n        return position;\n    }\n    _getPositionAfterNode(node, startPos) {\n        let position = node.getSelfHeight() + startPos;\n        if (node.children && node.isExpanded) { // TBD: consider loading component as well\n            position = this._getPositionAfter(node.visibleChildren, position);\n        }\n        node.height = position - startPos;\n        return position;\n    }\n    clear() {\n        this._dispose.forEach((d) => d());\n    }\n    setViewport(viewport) {\n        Object.assign(this, {\n            viewport,\n            x: viewport.scrollLeft,\n            yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\n            viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\n        });\n    }\n    scrollIntoView(node, force, scrollToMiddle = true) {\n        if (node.options.scrollContainer) {\n            const scrollContainer = node.options.scrollContainer;\n            const scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\n            const scrollContainerTop = scrollContainer.getBoundingClientRect().top;\n            const nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\n            if (force || // force scroll to node\n                nodeTop < scrollContainer.scrollTop || // node is above scroll container\n                nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) { // node is below container\n                scrollContainer.scrollTop = scrollToMiddle ?\n                    nodeTop - scrollContainerHeight / 2 : // scroll to middle\n                    nodeTop; // scroll to start\n            }\n        }\n        else {\n            if (force || // force scroll to node\n                node.position < this.y || // node is above viewport\n                node.position + node.getSelfHeight() > this.y + this.viewportHeight) { // node is below viewport\n                if (this.viewport) {\n                    this.viewport.scrollTop = scrollToMiddle ?\n                        node.position - this.viewportHeight / 2 : // scroll to middle\n                        node.position; // scroll to start\n                    this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\n                }\n            }\n        }\n    }\n    getViewportNodes(nodes) {\n        if (!nodes)\n            return [];\n        const visibleNodes = nodes.filter((node) => !node.isHidden);\n        if (!this.isEnabled())\n            return visibleNodes;\n        if (!this.viewportHeight || !visibleNodes.length)\n            return [];\n        // When loading children async this method is called before their height and position is calculated.\n        // In that case firstIndex === 0 and lastIndex === visibleNodes.length - 1 (e.g. 1000),\n        // which means that it loops through every visibleNodes item and push them into viewportNodes array.\n        // We can prevent nodes from being pushed to the array and wait for the appropriate calculations to take place\n        const lastVisibleNode = visibleNodes.slice(-1)[0];\n        if (!lastVisibleNode.height && lastVisibleNode.position === 0)\n            return [];\n        // Search for first node in the viewport using binary search\n        // Look for first node that starts after the beginning of the viewport (with buffer)\n        // Or that ends after the beginning of the viewport\n        const firstIndex = binarySearch(visibleNodes, (node) => {\n            return (node.position + Y_OFFSET > this.y) ||\n                (node.position + node.height > this.y);\n        });\n        // Search for last node in the viewport using binary search\n        // Look for first node that starts after the end of the viewport (with buffer)\n        const lastIndex = binarySearch(visibleNodes, (node) => {\n            return node.position - Y_OFFSET > this.y + this.viewportHeight;\n        }, firstIndex);\n        const viewportNodes = [];\n        for (let i = firstIndex; i <= lastIndex; i++) {\n            viewportNodes.push(visibleNodes[i]);\n        }\n        return viewportNodes;\n    }\n    fixScroll() {\n        const maxY = Math.max(0, this.totalHeight - this.viewportHeight);\n        if (this.y < 0)\n            this._setYBlocks(0);\n        if (this.y > maxY)\n            this._setYBlocks(maxY / Y_EPSILON);\n    }\n    /** @nocollapse */ static ɵfac = function TreeVirtualScroll_Factory(t) { return new (t || TreeVirtualScroll)(i0.ɵɵinject(TreeModel)); };\n    /** @nocollapse */ static ɵprov = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjectable({ token: TreeVirtualScroll, factory: TreeVirtualScroll.ɵfac });\n}\n__decorate$1([\n    observable$1,\n    __metadata$1(\"design:type\", Object)\n], TreeVirtualScroll.prototype, \"yBlocks\", void 0);\n__decorate$1([\n    observable$1,\n    __metadata$1(\"design:type\", Object)\n], TreeVirtualScroll.prototype, \"x\", void 0);\n__decorate$1([\n    observable$1,\n    __metadata$1(\"design:type\", Object)\n], TreeVirtualScroll.prototype, \"viewportHeight\", void 0);\n__decorate$1([\n    computed$1,\n    __metadata$1(\"design:type\", Object),\n    __metadata$1(\"design:paramtypes\", [])\n], TreeVirtualScroll.prototype, \"y\", null);\n__decorate$1([\n    computed$1,\n    __metadata$1(\"design:type\", Object),\n    __metadata$1(\"design:paramtypes\", [])\n], TreeVirtualScroll.prototype, \"totalHeight\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", [Object]),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"_setYBlocks\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", []),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"recalcPositions\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", [Object]),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"setViewport\", null);\n__decorate$1([\n    action$1,\n    __metadata$1(\"design:type\", Function),\n    __metadata$1(\"design:paramtypes\", [Object, Object, Object]),\n    __metadata$1(\"design:returntype\", void 0)\n], TreeVirtualScroll.prototype, \"scrollIntoView\", null);\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeVirtualScroll, [{\n        type: Injectable\n    }], () => [{ type: TreeModel }], { yBlocks: [], x: [], viewportHeight: [], y: [], totalHeight: [], _setYBlocks: [], recalcPositions: [], setViewport: [], scrollIntoView: [] }); })();\nfunction binarySearch(nodes, condition, firstIndex = 0) {\n    let index = firstIndex;\n    let toIndex = nodes.length - 1;\n    while (index !== toIndex) {\n        let midIndex = Math.floor((index + toIndex) / 2);\n        if (condition(nodes[midIndex])) {\n            toIndex = midIndex;\n        }\n        else {\n            if (index === midIndex)\n                index = toIndex;\n            else\n                index = midIndex;\n        }\n    }\n    return index;\n}\n\nconst _c0$9 = a0 => ({ $implicit: a0 });\nfunction LoadingComponent_span_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \"loading...\");\n    i0.ɵɵelementEnd();\n} }\nclass LoadingComponent {\n    template;\n    node;\n    /** @nocollapse */ static ɵfac = function LoadingComponent_Factory(t) { return new (t || LoadingComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: LoadingComponent, selectors: [[\"tree-loading-component\"]], inputs: { template: \"template\", node: \"node\" }, decls: 2, vars: 5, consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]], template: function LoadingComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, LoadingComponent_span_0_Template, 2, 0, \"span\", 0);\n            i0.ɵɵelementContainer(1, 1);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"ngIf\", !ctx.template);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c0$9, ctx.node));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoadingComponent, [{\n        type: Component,\n        args: [{\n                encapsulation: ViewEncapsulation.None,\n                selector: 'tree-loading-component',\n                template: `\n    <span *ngIf=\"!template\">loading...</span>\n    <ng-container\n      [ngTemplateOutlet]=\"template\"\n      [ngTemplateOutletContext]=\"{ $implicit: node }\">\n    </ng-container>\n  `,\n            }]\n    }], null, { template: [{\n            type: Input\n        }], node: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(LoadingComponent, { className: \"LoadingComponent\" }); })();\n\nconst _c0$8 = [\"*\"];\nconst _c1$2 = () => ({ dontDetach: true });\nfunction TreeViewportComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\");\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵstyleProp(\"height\", ctx_r0.getTotalHeight());\n} }\nclass TreeViewportComponent {\n    elementRef;\n    virtualScroll;\n    setViewport = this.throttle(() => {\n        this.virtualScroll.setViewport(this.elementRef.nativeElement);\n    }, 17);\n    scrollEventHandler;\n    constructor(elementRef, virtualScroll) {\n        this.elementRef = elementRef;\n        this.virtualScroll = virtualScroll;\n        this.scrollEventHandler = this.setViewport.bind(this);\n    }\n    ngOnInit() {\n        this.virtualScroll.init();\n    }\n    ngAfterViewInit() {\n        setTimeout(() => {\n            this.setViewport();\n            this.virtualScroll.fireEvent({ eventName: TREE_EVENTS.initialized });\n        });\n        let el = this.elementRef.nativeElement;\n        el.addEventListener('scroll', this.scrollEventHandler);\n    }\n    ngOnDestroy() {\n        this.virtualScroll.clear();\n        let el = this.elementRef.nativeElement;\n        el.removeEventListener('scroll', this.scrollEventHandler);\n    }\n    getTotalHeight() {\n        return ((this.virtualScroll.isEnabled() &&\n            this.virtualScroll.totalHeight + 'px') ||\n            'auto');\n    }\n    throttle(func, timeFrame) {\n        let lastTime = 0;\n        return function () {\n            let now = Date.now();\n            if (now - lastTime >= timeFrame) {\n                func();\n                lastTime = now;\n            }\n        };\n    }\n    /** @nocollapse */ static ɵfac = function TreeViewportComponent_Factory(t) { return new (t || TreeViewportComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TreeVirtualScroll)); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeViewportComponent, selectors: [[\"tree-viewport\"]], features: [i0.ɵɵProvidersFeature([TreeVirtualScroll])], ngContentSelectors: _c0$8, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"]], template: function TreeViewportComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵprojectionDef();\n            i0.ɵɵtemplate(0, TreeViewportComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c1$2));\n        } }, dependencies: [TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeViewportComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-viewport', providers: [TreeVirtualScroll], template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.height]=\"getTotalHeight()\">\n        <ng-content></ng-content>\n      </div>\n    </ng-container>\n  ` }]\n    }], () => [{ type: i0.ElementRef }, { type: TreeVirtualScroll }], null); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeViewportComponent, { className: \"TreeViewportComponent\" }); })();\n\nconst DRAG_OVER_CLASS$1 = 'is-dragging-over';\nconst DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';\nclass TreeDropDirective {\n    el;\n    renderer;\n    treeDraggedElement;\n    ngZone;\n    allowDragoverStyling = true;\n    onDropCallback = new EventEmitter();\n    onDragOverCallback = new EventEmitter();\n    onDragLeaveCallback = new EventEmitter();\n    onDragEnterCallback = new EventEmitter();\n    dragOverEventHandler;\n    dragEnterEventHandler;\n    dragLeaveEventHandler;\n    _allowDrop = (element, $event) => true;\n    set treeAllowDrop(allowDrop) {\n        if (allowDrop instanceof Function) {\n            this._allowDrop = allowDrop;\n        }\n        else\n            this._allowDrop = (element, $event) => allowDrop;\n    }\n    allowDrop($event) {\n        return this._allowDrop(this.treeDraggedElement.get(), $event);\n    }\n    constructor(el, renderer, treeDraggedElement, ngZone) {\n        this.el = el;\n        this.renderer = renderer;\n        this.treeDraggedElement = treeDraggedElement;\n        this.ngZone = ngZone;\n        this.dragOverEventHandler = this.onDragOver.bind(this);\n        this.dragEnterEventHandler = this.onDragEnter.bind(this);\n        this.dragLeaveEventHandler = this.onDragLeave.bind(this);\n    }\n    ngAfterViewInit() {\n        let el = this.el.nativeElement;\n        this.ngZone.runOutsideAngular(() => {\n            el.addEventListener('dragover', this.dragOverEventHandler);\n            el.addEventListener('dragenter', this.dragEnterEventHandler);\n            el.addEventListener('dragleave', this.dragLeaveEventHandler);\n        });\n    }\n    ngOnDestroy() {\n        let el = this.el.nativeElement;\n        el.removeEventListener('dragover', this.dragOverEventHandler);\n        el.removeEventListener('dragenter', this.dragEnterEventHandler);\n        el.removeEventListener('dragleave', this.dragLeaveEventHandler);\n    }\n    onDragOver($event) {\n        if (!this.allowDrop($event)) {\n            if (this.allowDragoverStyling) {\n                return this.addDisabledClass();\n            }\n            return;\n        }\n        this.onDragOverCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n        $event.preventDefault();\n        if (this.allowDragoverStyling) {\n            this.addClass();\n        }\n    }\n    onDragEnter($event) {\n        if (!this.allowDrop($event))\n            return;\n        $event.preventDefault();\n        this.onDragEnterCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n    }\n    onDragLeave($event) {\n        if (!this.allowDrop($event)) {\n            if (this.allowDragoverStyling) {\n                return this.removeDisabledClass();\n            }\n            return;\n        }\n        this.onDragLeaveCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n        if (this.allowDragoverStyling) {\n            this.removeClass();\n        }\n    }\n    onDrop($event) {\n        if (!this.allowDrop($event))\n            return;\n        $event.preventDefault();\n        this.onDropCallback.emit({ event: $event, element: this.treeDraggedElement.get() });\n        if (this.allowDragoverStyling) {\n            this.removeClass();\n        }\n        this.treeDraggedElement.set(null);\n    }\n    addClass() {\n        this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS$1);\n    }\n    removeClass() {\n        this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS$1);\n    }\n    addDisabledClass() {\n        this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n    }\n    removeDisabledClass() {\n        this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n    }\n    /** @nocollapse */ static ɵfac = function TreeDropDirective_Factory(t) { return new (t || TreeDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(TreeDraggedElement), i0.ɵɵdirectiveInject(i0.NgZone)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeDropDirective, selectors: [[\"\", \"treeDrop\", \"\"]], hostBindings: function TreeDropDirective_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"drop\", function TreeDropDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); });\n        } }, inputs: { allowDragoverStyling: \"allowDragoverStyling\", treeAllowDrop: \"treeAllowDrop\" }, outputs: { onDropCallback: \"treeDrop\", onDragOverCallback: \"treeDropDragOver\", onDragLeaveCallback: \"treeDropDragLeave\", onDragEnterCallback: \"treeDropDragEnter\" } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeDropDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[treeDrop]'\n            }]\n    }], () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: TreeDraggedElement }, { type: i0.NgZone }], { allowDragoverStyling: [{\n            type: Input\n        }], onDropCallback: [{\n            type: Output,\n            args: ['treeDrop']\n        }], onDragOverCallback: [{\n            type: Output,\n            args: ['treeDropDragOver']\n        }], onDragLeaveCallback: [{\n            type: Output,\n            args: ['treeDropDragLeave']\n        }], onDragEnterCallback: [{\n            type: Output,\n            args: ['treeDropDragEnter']\n        }], treeAllowDrop: [{\n            type: Input\n        }], onDrop: [{\n            type: HostListener,\n            args: ['drop', ['$event']]\n        }] }); })();\n\nclass TreeNodeDropSlot {\n    node;\n    dropIndex;\n    onDrop($event) {\n        this.node.mouseAction('drop', $event.event, {\n            from: $event.element,\n            to: { parent: this.node, index: this.dropIndex }\n        });\n    }\n    allowDrop(element, $event) {\n        return this.node.options.allowDrop(element, { parent: this.node, index: this.dropIndex }, $event);\n    }\n    /** @nocollapse */ static ɵfac = function TreeNodeDropSlot_Factory(t) { return new (t || TreeNodeDropSlot)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeDropSlot, selectors: [[\"TreeNodeDropSlot\"], [\"tree-node-drop-slot\"]], inputs: { node: \"node\", dropIndex: \"dropIndex\" }, decls: 1, vars: 2, consts: [[1, \"node-drop-slot\", 3, \"treeDrop\", \"treeAllowDrop\", \"allowDragoverStyling\"]], template: function TreeNodeDropSlot_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0);\n            i0.ɵɵlistener(\"treeDrop\", function TreeNodeDropSlot_Template_div_treeDrop_0_listener($event) { return ctx.onDrop($event); });\n            i0.ɵɵelementEnd();\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeAllowDrop\", ctx.allowDrop.bind(ctx))(\"allowDragoverStyling\", true);\n        } }, dependencies: [TreeDropDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeDropSlot, [{\n        type: Component,\n        args: [{ selector: 'TreeNodeDropSlot, tree-node-drop-slot', encapsulation: ViewEncapsulation.None, template: `\n    <div\n      class=\"node-drop-slot\"\n      (treeDrop)=\"onDrop($event)\"\n      [treeAllowDrop]=\"allowDrop.bind(this)\"\n      [allowDragoverStyling]=\"true\">\n    </div>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], dropIndex: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeDropSlot, { className: \"TreeNodeDropSlot\" }); })();\n\n// Re-export mobx operators to be able to use inside components with AOT:\nfunction actionInternal(...args) {\n    return action$1(...args);\n}\nconst action = Object.assign(actionInternal, action$1);\nfunction computedInternal(...args) {\n    return computed$1(...args);\n}\nconst computed = Object.assign(computedInternal, computed$1);\nfunction observableInternal(...args) {\n    return observable$1(...args);\n}\nconst observable = Object.assign(observableInternal, observable$1);\n\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _c0$7 = () => ({ dontDetach: true });\nfunction TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node\", 2);\n} if (rf & 2) {\n    const node_r1 = ctx.$implicit;\n    const i_r2 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"node\", node_r1)(\"index\", i_r2)(\"templates\", ctx_r2.templates);\n} }\nfunction TreeNodeCollectionComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\");\n    i0.ɵɵtemplate(2, TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template, 1, 3, \"tree-node\", 1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵstyleProp(\"margin-top\", ctx_r2.marginTop);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.viewportNodes)(\"ngForTrackBy\", ctx_r2.trackNode);\n} }\nclass TreeNodeCollectionComponent {\n    get nodes() {\n        return this._nodes;\n    }\n    set nodes(nodes) {\n        this.setNodes(nodes);\n    }\n    treeModel;\n    _nodes;\n    virtualScroll; // Cannot inject this, because we might be inside treeNodeTemplateFull\n    templates;\n    viewportNodes;\n    get marginTop() {\n        const firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];\n        const relativePosition = firstNode && firstNode.parent\n            ? firstNode.position -\n                firstNode.parent.position -\n                firstNode.parent.getSelfHeight()\n            : 0;\n        return `${relativePosition}px`;\n    }\n    _dispose = [];\n    setNodes(nodes) {\n        this._nodes = nodes;\n    }\n    ngOnInit() {\n        this.virtualScroll = this.treeModel.virtualScroll;\n        this._dispose = [\n            // return node indexes so we can compare structurally,\n            reaction(() => {\n                return this.virtualScroll\n                    .getViewportNodes(this.nodes)\n                    .map(n => n.index);\n            }, nodeIndexes => {\n                this.viewportNodes = nodeIndexes.map(i => this.nodes[i]);\n            }, { compareStructural: true, fireImmediately: true }),\n            reaction(() => this.nodes, nodes => {\n                this.viewportNodes = this.virtualScroll.getViewportNodes(nodes);\n            })\n        ];\n    }\n    ngOnDestroy() {\n        this._dispose.forEach(d => d());\n    }\n    trackNode(index, node) {\n        return node.id;\n    }\n    /** @nocollapse */ static ɵfac = function TreeNodeCollectionComponent_Factory(t) { return new (t || TreeNodeCollectionComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeCollectionComponent, selectors: [[\"tree-node-collection\"]], inputs: { nodes: \"nodes\", treeModel: \"treeModel\", templates: \"templates\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [3, \"node\", \"index\", \"templates\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"node\", \"index\", \"templates\"]], template: function TreeNodeCollectionComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeCollectionComponent_ng_container_0_Template, 3, 4, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$7));\n        } }, encapsulation: 2 });\n}\n__decorate([\n    observable,\n    __metadata(\"design:type\", Object)\n], TreeNodeCollectionComponent.prototype, \"_nodes\", void 0);\n__decorate([\n    observable,\n    __metadata(\"design:type\", Array)\n], TreeNodeCollectionComponent.prototype, \"viewportNodes\", void 0);\n__decorate([\n    computed,\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [])\n], TreeNodeCollectionComponent.prototype, \"marginTop\", null);\n__decorate([\n    action,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], TreeNodeCollectionComponent.prototype, \"setNodes\", null);\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeCollectionComponent, [{\n        type: Component,\n        args: [{\n                selector: 'tree-node-collection',\n                encapsulation: ViewEncapsulation.None,\n                template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.margin-top]=\"marginTop\">\n        <tree-node\n          *ngFor=\"let node of viewportNodes; let i = index; trackBy: trackNode\"\n          [node]=\"node\"\n          [index]=\"i\"\n          [templates]=\"templates\"\n        >\n        </tree-node>\n      </div>\n    </ng-container>\n  `\n            }]\n    }], null, { nodes: [{\n            type: Input\n        }], treeModel: [{\n            type: Input\n        }], _nodes: [], templates: [{\n            type: Input\n        }], viewportNodes: [], marginTop: [], setNodes: [] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeCollectionComponent, { className: \"TreeNodeCollectionComponent\" }); })();\n\nconst _c0$6 = [\"loadingTemplate\"];\nconst _c1$1 = [\"treeNodeTemplate\"];\nconst _c2 = [\"treeNodeWrapperTemplate\"];\nconst _c3 = [\"treeNodeFullTemplate\"];\nconst _c4 = [\"viewport\"];\nconst _c5 = (a0, a1, a2, a3) => ({ loadingTemplate: a0, treeNodeTemplate: a1, treeNodeWrapperTemplate: a2, treeNodeFullTemplate: a3 });\nfunction TreeComponent_tree_node_collection_3_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-collection\", 4);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"nodes\", ctx_r0.treeModel.roots)(\"treeModel\", ctx_r0.treeModel)(\"templates\", i0.ɵɵpureFunction4(3, _c5, ctx_r0.loadingTemplate, ctx_r0.treeNodeTemplate, ctx_r0.treeNodeWrapperTemplate, ctx_r0.treeNodeFullTemplate));\n} }\nfunction TreeComponent_tree_node_drop_slot_4_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-drop-slot\", 5);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"dropIndex\", 0)(\"node\", ctx_r0.treeModel.virtualRoot);\n} }\nclass TreeComponent {\n    treeModel;\n    treeDraggedElement;\n    _nodes;\n    _options;\n    loadingTemplate;\n    treeNodeTemplate;\n    treeNodeWrapperTemplate;\n    treeNodeFullTemplate;\n    viewportComponent;\n    // Will be handled in ngOnChanges\n    set nodes(nodes) {\n    }\n    ;\n    set options(options) {\n    }\n    ;\n    set focused(value) {\n        this.treeModel.setFocus(value);\n    }\n    set state(state) {\n        this.treeModel.setState(state);\n    }\n    toggleExpanded;\n    activate;\n    deactivate;\n    nodeActivate;\n    nodeDeactivate;\n    select;\n    deselect;\n    focus;\n    blur;\n    updateData;\n    initialized;\n    moveNode;\n    copyNode;\n    loadNodeChildren;\n    changeFilter;\n    event;\n    stateChange;\n    constructor(treeModel, treeDraggedElement) {\n        this.treeModel = treeModel;\n        this.treeDraggedElement = treeDraggedElement;\n        treeModel.eventNames.forEach((name) => this[name] = new EventEmitter());\n        treeModel.subscribeToState((state) => this.stateChange.emit(state));\n    }\n    onKeydown($event) {\n        if (!this.treeModel.isFocused)\n            return;\n        if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase()))\n            return;\n        const focusedNode = this.treeModel.getFocusedNode();\n        this.treeModel.performKeyAction(focusedNode, $event);\n    }\n    onMousedown($event) {\n        function isOutsideClick(startElement, nodeName) {\n            return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);\n        }\n        if (isOutsideClick($event.target, 'tree-root')) {\n            this.treeModel.setFocus(false);\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes.options || changes.nodes) {\n            this.treeModel.setData({\n                options: changes.options && changes.options.currentValue,\n                nodes: changes.nodes && changes.nodes.currentValue,\n                events: this.pick(this, this.treeModel.eventNames)\n            });\n        }\n    }\n    sizeChanged() {\n        this.viewportComponent.setViewport();\n    }\n    pick(object, keys) {\n        return keys.reduce((obj, key) => {\n            if (object && object.hasOwnProperty(key)) {\n                obj[key] = object[key];\n            }\n            return obj;\n        }, {});\n    }\n    /** @nocollapse */ static ɵfac = function TreeComponent_Factory(t) { return new (t || TreeComponent)(i0.ɵɵdirectiveInject(TreeModel), i0.ɵɵdirectiveInject(TreeDraggedElement)); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeComponent, selectors: [[\"Tree\"], [\"tree-root\"]], contentQueries: function TreeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n            i0.ɵɵcontentQuery(dirIndex, _c0$6, 5);\n            i0.ɵɵcontentQuery(dirIndex, _c1$1, 5);\n            i0.ɵɵcontentQuery(dirIndex, _c2, 5);\n            i0.ɵɵcontentQuery(dirIndex, _c3, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingTemplate = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeTemplate = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeWrapperTemplate = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeFullTemplate = _t.first);\n        } }, viewQuery: function TreeComponent_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵɵviewQuery(_c4, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewportComponent = _t.first);\n        } }, hostBindings: function TreeComponent_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"keydown\", function TreeComponent_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); }, false, i0.ɵɵresolveBody)(\"mousedown\", function TreeComponent_mousedown_HostBindingHandler($event) { return ctx.onMousedown($event); }, false, i0.ɵɵresolveBody);\n        } }, inputs: { nodes: \"nodes\", options: \"options\", focused: \"focused\", state: \"state\" }, outputs: { toggleExpanded: \"toggleExpanded\", activate: \"activate\", deactivate: \"deactivate\", nodeActivate: \"nodeActivate\", nodeDeactivate: \"nodeDeactivate\", select: \"select\", deselect: \"deselect\", focus: \"focus\", blur: \"blur\", updateData: \"updateData\", initialized: \"initialized\", moveNode: \"moveNode\", copyNode: \"copyNode\", loadNodeChildren: \"loadNodeChildren\", changeFilter: \"changeFilter\", event: \"event\", stateChange: \"stateChange\" }, features: [i0.ɵɵProvidersFeature([TreeModel]), i0.ɵɵNgOnChangesFeature], decls: 5, vars: 6, consts: [[\"viewport\", \"\"], [1, \"angular-tree-component\"], [3, \"nodes\", \"treeModel\", \"templates\", 4, \"ngIf\"], [\"class\", \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"treeModel\", \"templates\"], [1, \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\"]], template: function TreeComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"tree-viewport\", null, 0)(2, \"div\", 1);\n            i0.ɵɵtemplate(3, TreeComponent_tree_node_collection_3_Template, 1, 8, \"tree-node-collection\", 2)(4, TreeComponent_tree_node_drop_slot_4_Template, 1, 2, \"tree-node-drop-slot\", 3);\n            i0.ɵɵelementEnd()();\n        } if (rf & 2) {\n            i0.ɵɵadvance(2);\n            i0.ɵɵclassProp(\"node-dragging\", ctx.treeDraggedElement.isDragging())(\"angular-tree-component-rtl\", ctx.treeModel.options.rtl);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.treeModel.roots);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.treeModel.isEmptyTree());\n        } }, dependencies: [i1.NgIf, TreeNodeDropSlot, TreeNodeCollectionComponent, TreeViewportComponent], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeComponent, [{\n        type: Component,\n        args: [{ selector: 'Tree, tree-root', providers: [TreeModel], template: `\n      <tree-viewport #viewport>\n          <div\n                  class=\"angular-tree-component\"\n                  [class.node-dragging]=\"treeDraggedElement.isDragging()\"\n                  [class.angular-tree-component-rtl]=\"treeModel.options.rtl\">\n              <tree-node-collection\n                      *ngIf=\"treeModel.roots\"\n                      [nodes]=\"treeModel.roots\"\n                      [treeModel]=\"treeModel\"\n                      [templates]=\"{\n            loadingTemplate: loadingTemplate,\n            treeNodeTemplate: treeNodeTemplate,\n            treeNodeWrapperTemplate: treeNodeWrapperTemplate,\n            treeNodeFullTemplate: treeNodeFullTemplate\n          }\">\n              </tree-node-collection>\n              <tree-node-drop-slot\n                      class=\"empty-tree-drop-slot\"\n                      *ngIf=\"treeModel.isEmptyTree()\"\n                      [dropIndex]=\"0\"\n                      [node]=\"treeModel.virtualRoot\">\n              </tree-node-drop-slot>\n          </div>\n      </tree-viewport>\n  ` }]\n    }], () => [{ type: TreeModel }, { type: TreeDraggedElement }], { loadingTemplate: [{\n            type: ContentChild,\n            args: ['loadingTemplate', { static: false }]\n        }], treeNodeTemplate: [{\n            type: ContentChild,\n            args: ['treeNodeTemplate', { static: false }]\n        }], treeNodeWrapperTemplate: [{\n            type: ContentChild,\n            args: ['treeNodeWrapperTemplate', { static: false }]\n        }], treeNodeFullTemplate: [{\n            type: ContentChild,\n            args: ['treeNodeFullTemplate', { static: false }]\n        }], viewportComponent: [{\n            type: ViewChild,\n            args: ['viewport', { static: false }]\n        }], nodes: [{\n            type: Input\n        }], options: [{\n            type: Input\n        }], focused: [{\n            type: Input\n        }], state: [{\n            type: Input\n        }], toggleExpanded: [{\n            type: Output\n        }], activate: [{\n            type: Output\n        }], deactivate: [{\n            type: Output\n        }], nodeActivate: [{\n            type: Output\n        }], nodeDeactivate: [{\n            type: Output\n        }], select: [{\n            type: Output\n        }], deselect: [{\n            type: Output\n        }], focus: [{\n            type: Output\n        }], blur: [{\n            type: Output\n        }], updateData: [{\n            type: Output\n        }], initialized: [{\n            type: Output\n        }], moveNode: [{\n            type: Output\n        }], copyNode: [{\n            type: Output\n        }], loadNodeChildren: [{\n            type: Output\n        }], changeFilter: [{\n            type: Output\n        }], event: [{\n            type: Output\n        }], stateChange: [{\n            type: Output\n        }], onKeydown: [{\n            type: HostListener,\n            args: ['body: keydown', ['$event']]\n        }], onMousedown: [{\n            type: HostListener,\n            args: ['body: mousedown', ['$event']]\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeComponent, { className: \"TreeComponent\" }); })();\n\nconst EASE_ACCELERATION = 1.005;\nclass TreeAnimateOpenDirective {\n    renderer;\n    templateRef;\n    viewContainerRef;\n    _isOpen;\n    animateSpeed;\n    animateAcceleration;\n    isEnabled;\n    set isOpen(value) {\n        if (value) {\n            this._show();\n            if (this.isEnabled && this._isOpen === false) {\n                this._animateOpen();\n            }\n        }\n        else {\n            this.isEnabled ? this._animateClose() : this._hide();\n        }\n        this._isOpen = !!value;\n    }\n    ;\n    innerElement;\n    constructor(renderer, templateRef, viewContainerRef) {\n        this.renderer = renderer;\n        this.templateRef = templateRef;\n        this.viewContainerRef = viewContainerRef;\n    }\n    _show() {\n        if (this.innerElement)\n            return;\n        // create child view\n        this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];\n    }\n    _hide() {\n        this.viewContainerRef.clear();\n        this.innerElement = null;\n    }\n    _animateOpen() {\n        let delta = this.animateSpeed;\n        let ease = this.animateAcceleration;\n        let maxHeight = 0;\n        // set height to 0\n        this.renderer.setStyle(this.innerElement, 'max-height', `0`);\n        // increase maxHeight until height doesn't change\n        setTimeout(() => {\n            const i = setInterval(() => {\n                if (!this._isOpen || !this.innerElement)\n                    return clearInterval(i);\n                maxHeight += delta;\n                const roundedMaxHeight = Math.round(maxHeight);\n                this.renderer.setStyle(this.innerElement, 'max-height', `${roundedMaxHeight}px`);\n                const height = this.innerElement.getBoundingClientRect ? this.innerElement.getBoundingClientRect().height : 0; // TBD use renderer\n                delta *= ease;\n                ease *= EASE_ACCELERATION;\n                if (height < roundedMaxHeight) {\n                    // Make maxHeight auto because animation finished and container might change height later on\n                    this.renderer.setStyle(this.innerElement, 'max-height', null);\n                    clearInterval(i);\n                }\n            }, 17);\n        });\n    }\n    _animateClose() {\n        if (!this.innerElement)\n            return;\n        let delta = this.animateSpeed;\n        let ease = this.animateAcceleration;\n        let height = this.innerElement.getBoundingClientRect().height; // TBD use renderer\n        // slowly decrease maxHeight to 0, starting from current height\n        const i = setInterval(() => {\n            if (this._isOpen || !this.innerElement)\n                return clearInterval(i);\n            height -= delta;\n            this.renderer.setStyle(this.innerElement, 'max-height', `${height}px`);\n            delta *= ease;\n            ease *= EASE_ACCELERATION;\n            if (height <= 0) {\n                // after animation complete - remove child element\n                this.viewContainerRef.clear();\n                this.innerElement = null;\n                clearInterval(i);\n            }\n        }, 17);\n    }\n    /** @nocollapse */ static ɵfac = function TreeAnimateOpenDirective_Factory(t) { return new (t || TreeAnimateOpenDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeAnimateOpenDirective, selectors: [[\"\", \"treeAnimateOpen\", \"\"]], inputs: { animateSpeed: [i0.ɵɵInputFlags.None, \"treeAnimateOpenSpeed\", \"animateSpeed\"], animateAcceleration: [i0.ɵɵInputFlags.None, \"treeAnimateOpenAcceleration\", \"animateAcceleration\"], isEnabled: [i0.ɵɵInputFlags.None, \"treeAnimateOpenEnabled\", \"isEnabled\"], isOpen: [i0.ɵɵInputFlags.None, \"treeAnimateOpen\", \"isOpen\"] } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeAnimateOpenDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[treeAnimateOpen]'\n            }]\n    }], () => [{ type: i0.Renderer2 }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }], { animateSpeed: [{\n            type: Input,\n            args: ['treeAnimateOpenSpeed']\n        }], animateAcceleration: [{\n            type: Input,\n            args: ['treeAnimateOpenAcceleration']\n        }], isEnabled: [{\n            type: Input,\n            args: ['treeAnimateOpenEnabled']\n        }], isOpen: [{\n            type: Input,\n            args: ['treeAnimateOpen']\n        }] }); })();\n\nconst _c0$5 = () => ({ dontDetach: true });\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-collection\", 4);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"nodes\", ctx_r0.node.children)(\"templates\", ctx_r0.templates)(\"treeModel\", ctx_r0.node.treeModel);\n} }\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-loading-component\", 5);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"padding-left\", ctx_r0.node.getNodePadding());\n    i0.ɵɵproperty(\"template\", ctx_r0.templates.loadingTemplate)(\"node\", ctx_r0.node);\n} }\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template, 1, 3, \"tree-node-collection\", 2)(2, TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template, 1, 4, \"tree-loading-component\", 3);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"tree-children\", true)(\"tree-children-no-padding\", ctx_r0.node.options.levelPadding);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.node.children);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.node.children);\n} }\nfunction TreeNodeChildrenComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_Template, 3, 6, \"div\", 1);\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"treeAnimateOpen\", ctx_r0.node.isExpanded)(\"treeAnimateOpenSpeed\", ctx_r0.node.options.animateSpeed)(\"treeAnimateOpenAcceleration\", ctx_r0.node.options.animateAcceleration)(\"treeAnimateOpenEnabled\", ctx_r0.node.options.animateExpand);\n} }\nclass TreeNodeChildrenComponent {\n    node;\n    templates;\n    /** @nocollapse */ static ɵfac = function TreeNodeChildrenComponent_Factory(t) { return new (t || TreeNodeChildrenComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeChildrenComponent, selectors: [[\"tree-node-children\"]], inputs: { node: \"node\", templates: \"templates\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [3, \"tree-children\", \"tree-children-no-padding\", 4, \"treeAnimateOpen\", \"treeAnimateOpenSpeed\", \"treeAnimateOpenAcceleration\", \"treeAnimateOpenEnabled\"], [3, \"nodes\", \"templates\", \"treeModel\", 4, \"ngIf\"], [\"class\", \"tree-node-loading\", 3, \"padding-left\", \"template\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"templates\", \"treeModel\"], [1, \"tree-node-loading\", 3, \"template\", \"node\"]], template: function TreeNodeChildrenComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeChildrenComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$5));\n        } }, dependencies: [i1.NgIf, LoadingComponent, TreeNodeCollectionComponent, TreeAnimateOpenDirective, TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeChildrenComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-children', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div\n        [class.tree-children]=\"true\"\n        [class.tree-children-no-padding]=\"node.options.levelPadding\"\n        *treeAnimateOpen=\"\n          node.isExpanded;\n          speed: node.options.animateSpeed;\n          acceleration: node.options.animateAcceleration;\n          enabled: node.options.animateExpand\n        \"\n      >\n        <tree-node-collection\n          *ngIf=\"node.children\"\n          [nodes]=\"node.children\"\n          [templates]=\"templates\"\n          [treeModel]=\"node.treeModel\"\n        >\n        </tree-node-collection>\n        <tree-loading-component\n          [style.padding-left]=\"node.getNodePadding()\"\n          class=\"tree-node-loading\"\n          *ngIf=\"!node.children\"\n          [template]=\"templates.loadingTemplate\"\n          [node]=\"node\"\n        ></tree-loading-component>\n      </div>\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], templates: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeChildrenComponent, { className: \"TreeNodeChildrenComponent\" }); })();\n\nconst _c0$4 = (a0, a1, a2) => ({ $implicit: a0, node: a1, index: a2 });\nfunction TreeNodeContent_span_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r0.node.displayField);\n} }\nclass TreeNodeContent {\n    node;\n    index;\n    template;\n    /** @nocollapse */ static ɵfac = function TreeNodeContent_Factory(t) { return new (t || TreeNodeContent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeContent, selectors: [[\"tree-node-content\"]], inputs: { node: \"node\", index: \"index\", template: \"template\" }, decls: 2, vars: 7, consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]], template: function TreeNodeContent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeContent_span_0_Template, 2, 1, \"span\", 0);\n            i0.ɵɵelementContainer(1, 1);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"ngIf\", !ctx.template);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(3, _c0$4, ctx.node, ctx.node, ctx.index));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeContent, [{\n        type: Component,\n        args: [{\n                selector: 'tree-node-content',\n                encapsulation: ViewEncapsulation.None,\n                template: `\n  <span *ngIf=\"!template\">{{ node.displayField }}</span>\n  <ng-container\n    [ngTemplateOutlet]=\"template\"\n    [ngTemplateOutletContext]=\"{ $implicit: node, node: node, index: index }\">\n  </ng-container>`,\n            }]\n    }], null, { node: [{\n            type: Input\n        }], index: [{\n            type: Input\n        }], template: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeContent, { className: \"TreeNodeContent\" }); })();\n\nconst DRAG_OVER_CLASS = 'is-dragging-over';\nclass TreeDragDirective {\n    el;\n    renderer;\n    treeDraggedElement;\n    ngZone;\n    draggedElement;\n    treeDragEnabled;\n    dragEventHandler;\n    constructor(el, renderer, treeDraggedElement, ngZone) {\n        this.el = el;\n        this.renderer = renderer;\n        this.treeDraggedElement = treeDraggedElement;\n        this.ngZone = ngZone;\n        this.dragEventHandler = this.onDrag.bind(this);\n    }\n    ngAfterViewInit() {\n        let el = this.el.nativeElement;\n        this.ngZone.runOutsideAngular(() => {\n            el.addEventListener('drag', this.dragEventHandler);\n        });\n    }\n    ngDoCheck() {\n        this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\n    }\n    ngOnDestroy() {\n        let el = this.el.nativeElement;\n        el.removeEventListener('drag', this.dragEventHandler);\n    }\n    onDragStart(ev) {\n        // setting the data is required by firefox\n        ev.dataTransfer.setData('text', ev.target.id);\n        this.treeDraggedElement.set(this.draggedElement);\n        if (this.draggedElement.mouseAction) {\n            this.draggedElement.mouseAction('dragStart', ev);\n        }\n    }\n    onDrag(ev) {\n        if (this.draggedElement.mouseAction) {\n            this.draggedElement.mouseAction('drag', ev);\n        }\n    }\n    onDragEnd() {\n        if (this.draggedElement.mouseAction) {\n            this.draggedElement.mouseAction('dragEnd');\n        }\n        this.treeDraggedElement.set(null);\n    }\n    /** @nocollapse */ static ɵfac = function TreeDragDirective_Factory(t) { return new (t || TreeDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(TreeDraggedElement), i0.ɵɵdirectiveInject(i0.NgZone)); };\n    /** @nocollapse */ static ɵdir = /** @pureOrBreakMyCode */ i0.ɵɵdefineDirective({ type: TreeDragDirective, selectors: [[\"\", \"treeDrag\", \"\"]], hostBindings: function TreeDragDirective_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"dragstart\", function TreeDragDirective_dragstart_HostBindingHandler($event) { return ctx.onDragStart($event); })(\"dragend\", function TreeDragDirective_dragend_HostBindingHandler() { return ctx.onDragEnd(); });\n        } }, inputs: { draggedElement: [i0.ɵɵInputFlags.None, \"treeDrag\", \"draggedElement\"], treeDragEnabled: \"treeDragEnabled\" } });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeDragDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[treeDrag]'\n            }]\n    }], () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: TreeDraggedElement }, { type: i0.NgZone }], { draggedElement: [{\n            type: Input,\n            args: ['treeDrag']\n        }], treeDragEnabled: [{\n            type: Input\n        }], onDragStart: [{\n            type: HostListener,\n            args: ['dragstart', ['$event']]\n        }], onDragEnd: [{\n            type: HostListener,\n            args: ['dragend']\n        }] }); })();\n\nconst _c0$3 = () => ({ dontDetach: true });\nfunction TreeNodeExpanderComponent_ng_container_0_span_1_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵlistener(\"click\", function TreeNodeExpanderComponent_ng_container_0_span_1_Template_span_click_0_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(2); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"expanderClick\", $event)); });\n    i0.ɵɵelement(1, \"span\", 4);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"toggle-children-wrapper-expanded\", ctx_r1.node.isExpanded)(\"toggle-children-wrapper-collapsed\", ctx_r1.node.isCollapsed);\n} }\nfunction TreeNodeExpanderComponent_ng_container_0_span_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 5);\n} }\nfunction TreeNodeExpanderComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeNodeExpanderComponent_ng_container_0_span_1_Template, 2, 4, \"span\", 1)(2, TreeNodeExpanderComponent_ng_container_0_span_2_Template, 1, 0, \"span\", 2);\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.node.hasChildren);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.node.hasChildren);\n} }\nclass TreeNodeExpanderComponent {\n    node;\n    /** @nocollapse */ static ɵfac = function TreeNodeExpanderComponent_Factory(t) { return new (t || TreeNodeExpanderComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeExpanderComponent, selectors: [[\"tree-node-expander\"]], inputs: { node: \"node\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [\"class\", \"toggle-children-wrapper\", 3, \"toggle-children-wrapper-expanded\", \"toggle-children-wrapper-collapsed\", \"click\", 4, \"ngIf\"], [\"class\", \"toggle-children-placeholder\", 4, \"ngIf\"], [1, \"toggle-children-wrapper\", 3, \"click\"], [1, \"toggle-children\"], [1, \"toggle-children-placeholder\"]], template: function TreeNodeExpanderComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeExpanderComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$3));\n        } }, dependencies: [i1.NgIf, TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeExpanderComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-expander', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <span\n        *ngIf=\"node.hasChildren\"\n        [class.toggle-children-wrapper-expanded]=\"node.isExpanded\"\n        [class.toggle-children-wrapper-collapsed]=\"node.isCollapsed\"\n        class=\"toggle-children-wrapper\"\n        (click)=\"node.mouseAction('expanderClick', $event)\"\n      >\n        <span class=\"toggle-children\"></span>\n      </span>\n      <span *ngIf=\"!node.hasChildren\" class=\"toggle-children-placeholder\">\n      </span>\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeExpanderComponent, { className: \"TreeNodeExpanderComponent\" }); })();\n\nconst _c0$2 = () => ({ dontDetach: true });\nfunction TreeNodeCheckboxComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"input\", 1);\n    i0.ɵɵlistener(\"click\", function TreeNodeCheckboxComponent_ng_container_0_Template_input_click_1_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"checkboxClick\", $event)); });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"checked\", ctx_r1.node.isSelected)(\"indeterminate\", ctx_r1.node.isPartiallySelected);\n} }\nclass TreeNodeCheckboxComponent {\n    node;\n    /** @nocollapse */ static ɵfac = function TreeNodeCheckboxComponent_Factory(t) { return new (t || TreeNodeCheckboxComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeCheckboxComponent, selectors: [[\"tree-node-checkbox\"]], inputs: { node: \"node\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [\"type\", \"checkbox\", 1, \"tree-node-checkbox\", 3, \"click\", \"checked\", \"indeterminate\"]], template: function TreeNodeCheckboxComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeCheckboxComponent_ng_container_0_Template, 2, 2, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0$2));\n        } }, dependencies: [TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeCheckboxComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-checkbox', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <input\n        class=\"tree-node-checkbox\"\n        type=\"checkbox\"\n        (click)=\"node.mouseAction('checkboxClick', $event)\"\n        [checked]=\"node.isSelected\"\n        [indeterminate]=\"node.isPartiallySelected\"\n      />\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeCheckboxComponent, { className: \"TreeNodeCheckboxComponent\" }); })();\n\nconst _c0$1 = (a0, a1, a2, a3) => ({ $implicit: a0, node: a1, index: a2, templates: a3 });\nfunction TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-checkbox\", 4);\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"node\", ctx_r1.node);\n} }\nfunction TreeNodeWrapperComponent_div_0_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtemplate(1, TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template, 1, 1, \"tree-node-checkbox\", 3);\n    i0.ɵɵelement(2, \"tree-node-expander\", 4);\n    i0.ɵɵelementStart(3, \"div\", 5);\n    i0.ɵɵlistener(\"click\", function TreeNodeWrapperComponent_div_0_Template_div_click_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"click\", $event)); })(\"dblclick\", function TreeNodeWrapperComponent_div_0_Template_div_dblclick_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dblClick\", $event)); })(\"mouseover\", function TreeNodeWrapperComponent_div_0_Template_div_mouseover_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"mouseOver\", $event)); })(\"mouseout\", function TreeNodeWrapperComponent_div_0_Template_div_mouseout_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"mouseOut\", $event)); })(\"contextmenu\", function TreeNodeWrapperComponent_div_0_Template_div_contextmenu_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"contextMenu\", $event)); })(\"treeDrop\", function TreeNodeWrapperComponent_div_0_Template_div_treeDrop_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.onDrop($event)); })(\"treeDropDragOver\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragOver_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dragOver\", $event)); })(\"treeDropDragLeave\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragLeave_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dragLeave\", $event)); })(\"treeDropDragEnter\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragEnter_3_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.node.mouseAction(\"dragEnter\", $event)); });\n    i0.ɵɵelement(4, \"tree-node-content\", 6);\n    i0.ɵɵelementEnd()();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"padding-left\", ctx_r1.node.getNodePadding());\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.node.options.useCheckbox);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r1.node);\n    i0.ɵɵadvance();\n    i0.ɵɵclassProp(\"node-content-wrapper-active\", ctx_r1.node.isActive)(\"node-content-wrapper-focused\", ctx_r1.node.isFocused);\n    i0.ɵɵproperty(\"treeAllowDrop\", ctx_r1.node.allowDrop)(\"allowDragoverStyling\", ctx_r1.node.allowDragoverStyling())(\"treeDrag\", ctx_r1.node)(\"treeDragEnabled\", ctx_r1.node.allowDrag());\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r1.node)(\"index\", ctx_r1.index)(\"template\", ctx_r1.templates.treeNodeTemplate);\n} }\nclass TreeNodeWrapperComponent {\n    node;\n    index;\n    templates;\n    /** @nocollapse */ static ɵfac = function TreeNodeWrapperComponent_Factory(t) { return new (t || TreeNodeWrapperComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeWrapperComponent, selectors: [[\"tree-node-wrapper\"]], inputs: { node: \"node\", index: \"index\", templates: \"templates\" }, decls: 2, vars: 8, consts: [[\"class\", \"node-wrapper\", 3, \"padding-left\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"node-wrapper\"], [3, \"node\", 4, \"ngIf\"], [3, \"node\"], [1, \"node-content-wrapper\", 3, \"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"contextmenu\", \"treeDrop\", \"treeDropDragOver\", \"treeDropDragLeave\", \"treeDropDragEnter\", \"treeAllowDrop\", \"allowDragoverStyling\", \"treeDrag\", \"treeDragEnabled\"], [3, \"node\", \"index\", \"template\"]], template: function TreeNodeWrapperComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeWrapperComponent_div_0_Template, 5, 15, \"div\", 0);\n            i0.ɵɵelementContainer(1, 1);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"ngIf\", !ctx.templates.treeNodeWrapperTemplate);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templates.treeNodeWrapperTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(3, _c0$1, ctx.node, ctx.node, ctx.index, ctx.templates));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet, TreeNodeContent, TreeDropDirective, TreeDragDirective, TreeNodeExpanderComponent, TreeNodeCheckboxComponent], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeWrapperComponent, [{\n        type: Component,\n        args: [{ selector: 'tree-node-wrapper', encapsulation: ViewEncapsulation.None, template: `\n      <div *ngIf=\"!templates.treeNodeWrapperTemplate\" class=\"node-wrapper\" [style.padding-left]=\"node.getNodePadding()\">\n          <tree-node-checkbox *ngIf=\"node.options.useCheckbox\" [node]=\"node\"></tree-node-checkbox>\n          <tree-node-expander [node]=\"node\"></tree-node-expander>\n          <div class=\"node-content-wrapper\"\n               [class.node-content-wrapper-active]=\"node.isActive\"\n               [class.node-content-wrapper-focused]=\"node.isFocused\"\n               (click)=\"node.mouseAction('click', $event)\"\n               (dblclick)=\"node.mouseAction('dblClick', $event)\"\n               (mouseover)=\"node.mouseAction('mouseOver', $event)\"\n               (mouseout)=\"node.mouseAction('mouseOut', $event)\"\n               (contextmenu)=\"node.mouseAction('contextMenu', $event)\"\n               (treeDrop)=\"node.onDrop($event)\"\n               (treeDropDragOver)=\"node.mouseAction('dragOver', $event)\"\n               (treeDropDragLeave)=\"node.mouseAction('dragLeave', $event)\"\n               (treeDropDragEnter)=\"node.mouseAction('dragEnter', $event)\"\n               [treeAllowDrop]=\"node.allowDrop\"\n               [allowDragoverStyling]=\"node.allowDragoverStyling()\"\n               [treeDrag]=\"node\"\n               [treeDragEnabled]=\"node.allowDrag()\">\n\n              <tree-node-content [node]=\"node\" [index]=\"index\" [template]=\"templates.treeNodeTemplate\">\n              </tree-node-content>\n          </div>\n      </div>\n      <ng-container\n              [ngTemplateOutlet]=\"templates.treeNodeWrapperTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: node, node: node, index: index, templates: templates }\">\n      </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], index: [{\n            type: Input\n        }], templates: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeWrapperComponent, { className: \"TreeNodeWrapperComponent\" }); })();\n\nconst _c0 = () => ({ dontDetach: true });\nconst _c1 = (a0, a1, a2, a3) => ({ $implicit: a0, node: a1, index: a2, templates: a3 });\nfunction TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"tree-node-drop-slot\", 6);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"dropIndex\", ctx_r0.node.index)(\"node\", ctx_r0.node.parent);\n} }\nfunction TreeNodeComponent_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template, 1, 2, \"tree-node-drop-slot\", 3);\n    i0.ɵɵelement(2, \"tree-node-wrapper\", 4)(3, \"tree-node-children\", 5)(4, \"tree-node-drop-slot\", 6);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r0.node.getClass());\n    i0.ɵɵclassProp(\"tree-node\", true)(\"tree-node-expanded\", ctx_r0.node.isExpanded && ctx_r0.node.hasChildren)(\"tree-node-collapsed\", ctx_r0.node.isCollapsed && ctx_r0.node.hasChildren)(\"tree-node-leaf\", ctx_r0.node.isLeaf)(\"tree-node-active\", ctx_r0.node.isActive)(\"tree-node-focused\", ctx_r0.node.isFocused);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.index === 0);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r0.node)(\"index\", ctx_r0.index)(\"templates\", ctx_r0.templates);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"node\", ctx_r0.node)(\"templates\", ctx_r0.templates);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"dropIndex\", ctx_r0.node.index + 1)(\"node\", ctx_r0.node.parent);\n} }\nfunction TreeNodeComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_Template, 5, 22, \"div\", 1);\n    i0.ɵɵelementContainer(2, 2);\n    i0.ɵɵelementContainerEnd();\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.templates.treeNodeFullTemplate);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.templates.treeNodeFullTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(3, _c1, ctx_r0.node, ctx_r0.node, ctx_r0.index, ctx_r0.templates));\n} }\nclass TreeNodeComponent {\n    node;\n    index;\n    templates;\n    /** @nocollapse */ static ɵfac = function TreeNodeComponent_Factory(t) { return new (t || TreeNodeComponent)(); };\n    /** @nocollapse */ static ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: TreeNodeComponent, selectors: [[\"TreeNode\"], [\"tree-node\"]], inputs: { node: \"node\", index: \"index\", templates: \"templates\" }, decls: 1, vars: 2, consts: [[4, \"treeMobxAutorun\"], [3, \"class\", \"tree-node\", \"tree-node-expanded\", \"tree-node-collapsed\", \"tree-node-leaf\", \"tree-node-active\", \"tree-node-focused\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"node\", \"index\", \"templates\"], [3, \"node\", \"templates\"], [3, \"dropIndex\", \"node\"]], template: function TreeNodeComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵtemplate(0, TreeNodeComponent_ng_container_0_Template, 3, 8, \"ng-container\", 0);\n        } if (rf & 2) {\n            i0.ɵɵproperty(\"treeMobxAutorun\", i0.ɵɵpureFunction0(1, _c0));\n        } }, dependencies: [i1.NgIf, i1.NgTemplateOutlet, TreeNodeChildrenComponent, TreeNodeDropSlot, TreeNodeWrapperComponent, TreeMobxAutorunDirective], encapsulation: 2 });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeNodeComponent, [{\n        type: Component,\n        args: [{ selector: 'TreeNode, tree-node', encapsulation: ViewEncapsulation.None, template: `\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div\n        *ngIf=\"!templates.treeNodeFullTemplate\"\n        [class]=\"node.getClass()\"\n        [class.tree-node]=\"true\"\n        [class.tree-node-expanded]=\"node.isExpanded && node.hasChildren\"\n        [class.tree-node-collapsed]=\"node.isCollapsed && node.hasChildren\"\n        [class.tree-node-leaf]=\"node.isLeaf\"\n        [class.tree-node-active]=\"node.isActive\"\n        [class.tree-node-focused]=\"node.isFocused\"\n      >\n        <tree-node-drop-slot\n          *ngIf=\"index === 0\"\n          [dropIndex]=\"node.index\"\n          [node]=\"node.parent\"\n        ></tree-node-drop-slot>\n\n        <tree-node-wrapper\n          [node]=\"node\"\n          [index]=\"index\"\n          [templates]=\"templates\"\n        ></tree-node-wrapper>\n\n        <tree-node-children\n          [node]=\"node\"\n          [templates]=\"templates\"\n        ></tree-node-children>\n        <tree-node-drop-slot\n          [dropIndex]=\"node.index + 1\"\n          [node]=\"node.parent\"\n        ></tree-node-drop-slot>\n      </div>\n      <ng-container\n        [ngTemplateOutlet]=\"templates.treeNodeFullTemplate\"\n        [ngTemplateOutletContext]=\"{\n          $implicit: node,\n          node: node,\n          index: index,\n          templates: templates\n        }\"\n      >\n      </ng-container>\n    </ng-container>\n  ` }]\n    }], null, { node: [{\n            type: Input\n        }], index: [{\n            type: Input\n        }], templates: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(TreeNodeComponent, { className: \"TreeNodeComponent\" }); })();\n\nclass TreeModule {\n    /** @nocollapse */ static ɵfac = function TreeModule_Factory(t) { return new (t || TreeModule)(); };\n    /** @nocollapse */ static ɵmod = /** @pureOrBreakMyCode */ i0.ɵɵdefineNgModule({ type: TreeModule });\n    /** @nocollapse */ static ɵinj = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjector({ imports: [CommonModule] });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TreeModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    TreeComponent,\n                    TreeNodeComponent,\n                    TreeNodeContent,\n                    LoadingComponent,\n                    TreeDropDirective,\n                    TreeDragDirective,\n                    TreeNodeExpanderComponent,\n                    TreeNodeChildrenComponent,\n                    TreeNodeDropSlot,\n                    TreeNodeCollectionComponent,\n                    TreeViewportComponent,\n                    TreeNodeWrapperComponent,\n                    TreeNodeCheckboxComponent,\n                    TreeAnimateOpenDirective,\n                    TreeMobxAutorunDirective\n                ],\n                exports: [\n                    TreeComponent,\n                    TreeNodeComponent,\n                    TreeNodeContent,\n                    LoadingComponent,\n                    TreeDropDirective,\n                    TreeDragDirective,\n                    TreeNodeExpanderComponent,\n                    TreeNodeChildrenComponent,\n                    TreeNodeDropSlot,\n                    TreeNodeCollectionComponent,\n                    TreeViewportComponent,\n                    TreeNodeWrapperComponent,\n                    TreeNodeCheckboxComponent,\n                    TreeAnimateOpenDirective,\n                    TreeMobxAutorunDirective\n                ],\n                imports: [CommonModule],\n                providers: []\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(TreeModule, { declarations: [TreeComponent,\n        TreeNodeComponent,\n        TreeNodeContent,\n        LoadingComponent,\n        TreeDropDirective,\n        TreeDragDirective,\n        TreeNodeExpanderComponent,\n        TreeNodeChildrenComponent,\n        TreeNodeDropSlot,\n        TreeNodeCollectionComponent,\n        TreeViewportComponent,\n        TreeNodeWrapperComponent,\n        TreeNodeCheckboxComponent,\n        TreeAnimateOpenDirective,\n        TreeMobxAutorunDirective], imports: [CommonModule], exports: [TreeComponent,\n        TreeNodeComponent,\n        TreeNodeContent,\n        LoadingComponent,\n        TreeDropDirective,\n        TreeDragDirective,\n        TreeNodeExpanderComponent,\n        TreeNodeChildrenComponent,\n        TreeNodeDropSlot,\n        TreeNodeCollectionComponent,\n        TreeViewportComponent,\n        TreeNodeWrapperComponent,\n        TreeNodeCheckboxComponent,\n        TreeAnimateOpenDirective,\n        TreeMobxAutorunDirective] }); })();\ni0.ɵɵsetComponentScope(TreeNodeCollectionComponent, [i1.NgForOf, TreeNodeComponent,\n    TreeMobxAutorunDirective], []);\n\n/*\n * Public API Surface of angular-tree-component\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { KEYS, LoadingComponent, TREE_ACTIONS, TreeAnimateOpenDirective, TreeComponent, TreeDragDirective, TreeDraggedElement, TreeDropDirective, TreeMobxAutorunDirective, TreeModel, TreeModule, TreeNode, TreeNodeCheckboxComponent, TreeNodeChildrenComponent, TreeNodeCollectionComponent, TreeNodeComponent, TreeNodeContent, TreeNodeDropSlot, TreeNodeExpanderComponent, TreeNodeWrapperComponent, TreeViewportComponent, TreeVirtualScroll };\n//# sourceMappingURL=circlon-angular-tree-component.mjs.map\n","map":null,"preliminaryFileName":"circlon-angular-tree-component.mjs","sourcemapFileName":"circlon-angular-tree-component.mjs.map"},{"fileName":"circlon-angular-tree-component.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"circlon-angular-tree-component.mjs\",\"sources\":[\"../../../projects/angular-tree-component/src/lib/mobx-angular/tree-mobx-autorun.directive.ts\",\"../../../projects/angular-tree-component/src/lib/constants/keys.ts\",\"../../../projects/angular-tree-component/src/lib/models/tree-options.model.ts\",\"../../../projects/angular-tree-component/src/lib/constants/events.ts\",\"../../../projects/angular-tree-component/src/lib/models/tree-node.model.ts\",\"../../../projects/angular-tree-component/src/lib/models/tree.model.ts\",\"../../../projects/angular-tree-component/src/lib/models/tree-dragged-element.model.ts\",\"../../../projects/angular-tree-component/src/lib/models/tree-virtual-scroll.model.ts\",\"../../../projects/angular-tree-component/src/lib/components/loading.component.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-viewport.component.ts\",\"../../../projects/angular-tree-component/src/lib/directives/tree-drop.directive.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-drop-slot.component.ts\",\"../../../projects/angular-tree-component/src/lib/mobx-angular/mobx-proxy.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-collection.component.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree.component.ts\",\"../../../projects/angular-tree-component/src/lib/directives/tree-animate-open.directive.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-children.component.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-content.component.ts\",\"../../../projects/angular-tree-component/src/lib/directives/tree-drag.directive.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-expander.component.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-checkbox.component.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node-wrapper.component.ts\",\"../../../projects/angular-tree-component/src/lib/components/tree-node.component.ts\",\"../../../projects/angular-tree-component/src/lib/angular-tree-component.module.ts\",\"../../../projects/angular-tree-component/src/public-api.ts\",\"../../../projects/angular-tree-component/src/circlon-angular-tree-component.ts\"],\"sourcesContent\":[\"import {\\n  Directive,\\n  ViewContainerRef,\\n  TemplateRef,\\n  OnInit,\\n  OnDestroy,\\n  Input,\\n  EmbeddedViewRef\\n} from '@angular/core';\\nimport { autorun } from 'mobx';\\n\\n@Directive({ selector: '[treeMobxAutorun]' })\\nexport class TreeMobxAutorunDirective implements OnInit, OnDestroy {\\n  protected templateBindings = {};\\n  protected dispose: any;\\n  protected view: EmbeddedViewRef<any>;\\n  @Input() treeMobxAutorun;\\n\\n  constructor(\\n    protected templateRef: TemplateRef<any>,\\n    protected viewContainer: ViewContainerRef\\n  ) {}\\n\\n  ngOnInit() {\\n    this.view = this.viewContainer.createEmbeddedView(this.templateRef);\\n\\n    if (this.dispose) {\\n      this.dispose();\\n    }\\n\\n    if (this.shouldDetach()) {\\n      this.view.detach();\\n    }\\n    this.autoDetect(this.view);\\n  }\\n\\n  shouldDetach() {\\n    return this.treeMobxAutorun && this.treeMobxAutorun.detach;\\n  }\\n\\n  autoDetect(view: EmbeddedViewRef<any>) {\\n    this.dispose = autorun(() => view.detectChanges());\\n  }\\n\\n  ngOnDestroy() {\\n    if (this.dispose) {\\n      this.dispose();\\n    }\\n  }\\n}\\n\",\"export const KEYS = {\\n  LEFT: 37,\\n  UP: 38,\\n  RIGHT: 39,\\n  DOWN: 40,\\n  ENTER: 13,\\n  SPACE: 32,\\n  CONTEXT_MENU: 32\\n};\\n\",\"import { TreeNode } from './tree-node.model';\\nimport { TreeModel } from './tree.model';\\nimport { KEYS } from '../constants/keys';\\nimport { ITreeOptions } from '../defs/api';\\n\\nexport interface IActionHandler {\\n  (tree: TreeModel, node: TreeNode, $event: any, ...rest);\\n}\\n\\nexport const TREE_ACTIONS = {\\n  TOGGLE_ACTIVE: (tree: TreeModel, node: TreeNode, $event: any) => node && node.toggleActivated(),\\n  TOGGLE_ACTIVE_MULTI: (tree: TreeModel, node: TreeNode, $event: any) => node && node.toggleActivated(true),\\n  TOGGLE_SELECTED: (tree: TreeModel, node: TreeNode, $event: any) => node && node.toggleSelected(),\\n  ACTIVATE: (tree: TreeModel, node: TreeNode, $event: any) => node.setIsActive(true),\\n  DEACTIVATE: (tree: TreeModel, node: TreeNode, $event: any) => node.setIsActive(false),\\n  SELECT: (tree: TreeModel, node: TreeNode, $event: any) => node.setIsSelected(true),\\n  DESELECT: (tree: TreeModel, node: TreeNode, $event: any) => node.setIsSelected(false),\\n  FOCUS: (tree: TreeModel, node: TreeNode, $event: any) => node.focus(),\\n  TOGGLE_EXPANDED: (tree: TreeModel, node: TreeNode, $event: any) => node.hasChildren && node.toggleExpanded(),\\n  EXPAND: (tree: TreeModel, node: TreeNode, $event: any) => node.expand(),\\n  COLLAPSE: (tree: TreeModel, node: TreeNode, $event: any) => node.collapse(),\\n  DRILL_DOWN: (tree: TreeModel, node: TreeNode, $event: any) => tree.focusDrillDown(),\\n  DRILL_UP: (tree: TreeModel, node: TreeNode, $event: any) => tree.focusDrillUp(),\\n  NEXT_NODE: (tree: TreeModel, node: TreeNode, $event: any) =>  tree.focusNextNode(),\\n  PREVIOUS_NODE: (tree: TreeModel, node: TreeNode, $event: any) =>  tree.focusPreviousNode(),\\n  MOVE_NODE: (tree: TreeModel, node: TreeNode, $event: any, {from , to}: {from: any, to: any}) => {\\n    // default action assumes from = node, to = {parent, index}\\n    if ($event.ctrlKey) {\\n      tree.copyNode(from, to);\\n    } else {\\n      tree.moveNode(from, to);\\n    }\\n  }\\n};\\n\\nconst defaultActionMapping: IActionMapping = {\\n  mouse: {\\n    click: TREE_ACTIONS.TOGGLE_ACTIVE,\\n    dblClick: null,\\n    contextMenu: null,\\n    expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,\\n    checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,\\n    drop: TREE_ACTIONS.MOVE_NODE\\n  },\\n  keys: {\\n    [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\\n    [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\\n    [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\\n    [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\\n    [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\\n    [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\\n  }\\n};\\n\\nexport interface IActionMapping {\\n  mouse?: {\\n    click?: IActionHandler,\\n    dblClick?: IActionHandler,\\n    contextMenu?: IActionHandler,\\n    expanderClick?: IActionHandler,\\n    checkboxClick?: IActionHandler,\\n    dragStart?: IActionHandler,\\n    drag?: IActionHandler,\\n    dragEnd?: IActionHandler,\\n    dragOver?: IActionHandler,\\n    dragLeave?: IActionHandler,\\n    dragEnter?: IActionHandler,\\n    drop?: IActionHandler,\\n    mouseOver?: IActionHandler,\\n    mouseOut?: IActionHandler\\n  };\\n  keys?: {\\n    [key: number]: IActionHandler\\n  };\\n}\\n\\nexport class TreeOptions {\\n  get hasChildrenField(): string { return this.options.hasChildrenField || 'hasChildren'; }\\n  get childrenField(): string { return this.options.childrenField || 'children'; }\\n  get displayField(): string { return this.options.displayField || 'name'; }\\n  get idField(): string { return this.options.idField || 'id'; }\\n  get isExpandedField(): string { return this.options.isExpandedField || 'isExpanded'; }\\n  get getChildren(): any { return this.options.getChildren; }\\n  get levelPadding(): number { return this.options.levelPadding || 0; }\\n  get useVirtualScroll(): boolean { return this.options.useVirtualScroll; }\\n  get animateExpand(): boolean { return this.options.animateExpand; }\\n  get animateSpeed(): number { return this.options.animateSpeed || 1; }\\n  get animateAcceleration(): number { return this.options.animateAcceleration || 1.2; }\\n  get scrollOnActivate(): boolean { return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate; }\\n  get rtl(): boolean { return !!this.options.rtl; }\\n  get rootId(): any {return this.options.rootId; }\\n  get useCheckbox(): boolean { return this.options.useCheckbox; }\\n  get useTriState(): boolean { return this.options.useTriState === undefined ? true : this.options.useTriState; }\\n  get scrollContainer(): HTMLElement { return this.options.scrollContainer; }\\n  get allowDragoverStyling(): boolean { return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling; }\\n  actionMapping: IActionMapping;\\n\\n  constructor(private options: ITreeOptions = {}) {\\n    this.actionMapping = {\\n      mouse: {\\n        click: this.options?.actionMapping?.mouse?.click ?? defaultActionMapping.mouse.click,\\n        dblClick: this.options?.actionMapping?.mouse?.dblClick ?? defaultActionMapping.mouse.dblClick,\\n        contextMenu: this.options?.actionMapping?.mouse?.contextMenu ?? defaultActionMapping.mouse.contextMenu,\\n        expanderClick: this.options?.actionMapping?.mouse?.expanderClick ?? defaultActionMapping.mouse.expanderClick,\\n        checkboxClick: this.options?.actionMapping?.mouse?.checkboxClick ?? defaultActionMapping.mouse.checkboxClick,\\n        drop: this.options?.actionMapping?.mouse?.drop ?? defaultActionMapping.mouse.drop,\\n        dragStart: this.options?.actionMapping?.mouse?.dragStart ?? undefined,\\n        drag: this.options?.actionMapping?.mouse?.drag ?? undefined,\\n        dragEnd: this.options?.actionMapping?.mouse?.dragEnd ?? undefined,\\n        dragOver: this.options?.actionMapping?.mouse?.dragOver ?? undefined,\\n        dragLeave: this.options?.actionMapping?.mouse?.dragLeave ?? undefined,\\n        dragEnter: this.options?.actionMapping?.mouse?.dragEnter ?? undefined,\\n        mouseOver: this.options?.actionMapping?.mouse?.mouseOver ?? undefined,\\n        mouseOut: this.options?.actionMapping?.mouse?.mouseOut ?? undefined,\\n      },\\n      keys: {\\n        [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\\n        [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\\n        [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\\n        [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\\n        [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\\n        [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\\n      }\\n    }\\n\\n    if (this.options?.actionMapping?.keys) {\\n      this.actionMapping.keys = {\\n        ...this.actionMapping.keys,\\n        ...this.options.actionMapping.keys\\n      }\\n    }\\n\\n    if (options.rtl) {\\n      this.actionMapping.keys[KEYS.RIGHT] = <IActionHandler>options.actionMapping?.keys[KEYS.RIGHT] || TREE_ACTIONS.DRILL_UP;\\n      this.actionMapping.keys[KEYS.LEFT] = <IActionHandler>options.actionMapping?.keys[KEYS.LEFT] || TREE_ACTIONS.DRILL_DOWN;\\n    }\\n  }\\n\\n  getNodeClone(node: TreeNode): any {\\n    if (this.options.getNodeClone) {\\n      return this.options.getNodeClone(node);\\n    }\\n\\n    // remove id from clone\\n    // keeping ie11 compatibility\\n    const nodeClone = Object.assign({}, node.data);\\n    if (nodeClone.id) {\\n      delete nodeClone.id;\\n    }\\n    return nodeClone;\\n  }\\n\\n  allowDrop(element, to, $event?): boolean {\\n    if (this.options.allowDrop instanceof Function) {\\n      return this.options.allowDrop(element, to, $event);\\n    }\\n    else {\\n      return this.options.allowDrop === undefined ? true : this.options.allowDrop;\\n    }\\n  }\\n\\n  allowDrag(node: TreeNode): boolean {\\n    if (this.options.allowDrag instanceof Function) {\\n      return this.options.allowDrag(node);\\n    } else {\\n      return this.options.allowDrag;\\n    }\\n  }\\n\\n  nodeClass(node: TreeNode): string {\\n    return this.options.nodeClass ? this.options.nodeClass(node) : '';\\n  }\\n\\n  nodeHeight(node: TreeNode): number {\\n    if (node.data.virtual) {\\n      return 0;\\n    }\\n\\n    let nodeHeight = this.options.nodeHeight || 22;\\n\\n    if (typeof nodeHeight === 'function') {\\n      nodeHeight = nodeHeight(node);\\n    }\\n\\n    // account for drop slots:\\n    return nodeHeight + (node.index === 0 ?  2 : 1) * this.dropSlotHeight;\\n  }\\n\\n  get dropSlotHeight(): number {\\n    return typeof this.options.dropSlotHeight === 'number' ? this.options.dropSlotHeight : 2;\\n  }\\n}\\n\",\"export const TREE_EVENTS = {\\n  toggleExpanded: 'toggleExpanded',\\n  activate: 'activate',\\n  deactivate: 'deactivate',\\n  nodeActivate: 'nodeActivate',\\n  nodeDeactivate: 'nodeDeactivate',\\n  select: 'select',\\n  deselect: 'deselect',\\n  focus: 'focus',\\n  blur: 'blur',\\n  initialized: 'initialized',\\n  updateData: 'updateData',\\n  moveNode: 'moveNode',\\n  copyNode: 'copyNode',\\n  event: 'event',\\n  loadNodeChildren: 'loadNodeChildren',\\n  changeFilter: 'changeFilter',\\n  stateChange: 'stateChange'\\n};\\n\",\"import { observable, computed, reaction, autorun, action, IReactionDisposer } from 'mobx';\\nimport { TreeModel } from './tree.model';\\nimport { TreeOptions } from './tree-options.model';\\nimport { ITreeNode } from '../defs/api';\\nimport { TREE_EVENTS } from '../constants/events';\\n\\nexport class TreeNode implements ITreeNode {\\n  private handler: IReactionDisposer;\\n  @computed get isHidden() { return this.treeModel.isHidden(this); };\\n  @computed get isExpanded() { return this.treeModel.isExpanded(this); };\\n  @computed get isActive() { return this.treeModel.isActive(this); };\\n  @computed get isFocused() { return this.treeModel.isNodeFocused(this); };\\n  @computed get isSelected() {\\n    if (this.isSelectable()) {\\n        return this.treeModel.isSelected(this);\\n    } else {\\n      return this.children.some((node: TreeNode) => node.isSelected);\\n    }\\n  };\\n  @computed get isAllSelected() {\\n    if (this.isSelectable()) {\\n      return this.treeModel.isSelected(this);\\n    } else {\\n      return this.children.every((node: TreeNode) => node.isAllSelected);\\n    }\\n  };\\n  @computed get isPartiallySelected() {\\n    return this.isSelected && !this.isAllSelected;\\n  }\\n\\n  @observable children: TreeNode[];\\n  @observable index: number;\\n  @observable position = 0;\\n  @observable height: number;\\n  @computed get level(): number {\\n    return this.parent ? this.parent.level + 1 : 0;\\n  }\\n  @computed get path(): string[] {\\n    return this.parent ? [...this.parent.path, this.id] : [];\\n  }\\n\\n  get elementRef(): any {\\n    throw `Element Ref is no longer supported since introducing virtual scroll\\\\n\\n      You may use a template to obtain a reference to the element`;\\n  }\\n\\n  private _originalNode: any;\\n  get originalNode() { return this._originalNode; };\\n\\n  constructor(public data: any, public parent: TreeNode, public treeModel: TreeModel, index: number) {\\n    if (this.id === undefined || this.id === null) {\\n      this.id = uuid();\\n    } // Make sure there's a unique id without overriding existing ids to work with immutable data structures\\n    this.index = index;\\n\\n    if (this.getField('children')) {\\n      this._initChildren();\\n    }\\n    this.autoLoadChildren();\\n  }\\n\\n  // helper get functions:\\n  get hasChildren(): boolean {\\n    return !!(this.getField('hasChildren') || (this.children && this.children.length > 0));\\n  }\\n  get isCollapsed(): boolean { return !this.isExpanded; }\\n  get isLeaf(): boolean { return !this.hasChildren; }\\n  get isRoot(): boolean { return this.parent.data.virtual; }\\n  get realParent(): TreeNode { return this.isRoot ? null : this.parent; }\\n\\n  // proxy functions:\\n  get options(): TreeOptions { return this.treeModel.options; }\\n  fireEvent(event) { this.treeModel.fireEvent(event); }\\n\\n  // field accessors:\\n  get displayField() {\\n    return this.getField('display');\\n  }\\n\\n  get id() {\\n    return this.getField('id');\\n  }\\n\\n  set id(value) {\\n    this.setField('id', value);\\n  }\\n\\n  getField(key) {\\n    return this.data[this.options[`${key}Field`]];\\n  }\\n\\n  setField(key, value) {\\n    this.data[this.options[`${key}Field`]] = value;\\n  }\\n\\n  // traversing:\\n  _findAdjacentSibling(steps, skipHidden = false) {\\n    const siblings = this._getParentsChildren(skipHidden);\\n    const index = siblings.indexOf(this);\\n\\n    return siblings.length > index + steps ? siblings[index + steps] : null;\\n  }\\n\\n  findNextSibling(skipHidden = false) {\\n    return this._findAdjacentSibling(+1, skipHidden);\\n  }\\n\\n  findPreviousSibling(skipHidden = false) {\\n    return this._findAdjacentSibling(-1, skipHidden);\\n  }\\n\\n  getVisibleChildren() {\\n    return this.visibleChildren;\\n  }\\n\\n  @computed get visibleChildren() {\\n    return (this.children || []).filter((node) => !node.isHidden);\\n  }\\n\\n  getFirstChild(skipHidden = false) {\\n    let children = skipHidden ? this.visibleChildren : this.children;\\n\\n    return children != null && children.length ? children[0] : null;\\n  }\\n\\n  getLastChild(skipHidden = false) {\\n    let children = skipHidden ? this.visibleChildren : this.children;\\n\\n    return children != null && children.length ? children[children.length - 1] : null;\\n  }\\n\\n  findNextNode(goInside = true, skipHidden = false) {\\n    return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||\\n           this.findNextSibling(skipHidden) ||\\n           this.parent && this.parent.findNextNode(false, skipHidden);\\n  }\\n\\n  findPreviousNode(skipHidden = false) {\\n    let previousSibling = this.findPreviousSibling(skipHidden);\\n    if (!previousSibling) {\\n      return this.realParent;\\n    }\\n    return previousSibling._getLastOpenDescendant(skipHidden);\\n  }\\n\\n  _getLastOpenDescendant(skipHidden = false) {\\n    const lastChild = this.getLastChild(skipHidden);\\n    return (this.isCollapsed || !lastChild)\\n      ? this\\n      : lastChild._getLastOpenDescendant(skipHidden);\\n  }\\n\\n  private _getParentsChildren(skipHidden = false): any[] {\\n    const children = this.parent &&\\n      (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);\\n\\n    return children || [];\\n  }\\n\\n  private getIndexInParent(skipHidden = false) {\\n    return this._getParentsChildren(skipHidden).indexOf(this);\\n  }\\n\\n  isDescendantOf(node: TreeNode) {\\n    if (this === node) return true;\\n    else return this.parent && this.parent.isDescendantOf(node);\\n  }\\n\\n  getNodePadding(): string {\\n    return this.options.levelPadding * (this.level - 1) + 'px';\\n  }\\n\\n  getClass(): string {\\n    return [this.options.nodeClass(this), `tree-node-level-${ this.level }`].join(' ');\\n  }\\n\\n  onDrop($event) {\\n    this.mouseAction('drop', $event.event, {\\n      from: $event.element,\\n      to: { parent: this, index: 0, dropOnNode: true }\\n    });\\n  }\\n\\n  allowDrop = (element, $event?) => {\\n    return this.options.allowDrop(element, { parent: this, index: 0 }, $event);\\n  }\\n\\n  allowDragoverStyling = () => {\\n    return this.options.allowDragoverStyling;\\n  }\\n\\n  allowDrag() {\\n    return this.options.allowDrag(this);\\n  }\\n\\n\\n  // helper methods:\\n  loadNodeChildren() {\\n    if (!this.options.getChildren) {\\n      return Promise.resolve(); // Not getChildren method - for using redux\\n    }\\n    return Promise.resolve(this.options.getChildren(this))\\n      .then((children) => {\\n        if (children) {\\n          this.setField('children', children);\\n          this._initChildren();\\n          if (this.options.useTriState && this.treeModel.isSelected(this)) {\\n            this.setIsSelected(true);\\n          }\\n          this.children.forEach((child) => {\\n            if (child.getField('isExpanded') && child.hasChildren) {\\n              child.expand();\\n            }\\n          });\\n      }}).then(() => {\\n        this.fireEvent({\\n          eventName: TREE_EVENTS.loadNodeChildren,\\n          node: this\\n        });\\n      });\\n  }\\n\\n  expand() {\\n    if (!this.isExpanded) {\\n      this.toggleExpanded();\\n    }\\n\\n    return this;\\n  }\\n\\n  collapse() {\\n    if (this.isExpanded) {\\n      this.toggleExpanded();\\n    }\\n\\n    return this;\\n  }\\n\\n  doForAll(fn: (node: ITreeNode) => any) {\\n    Promise.resolve(fn(this)).then(() => {\\n      if (this.children) {\\n        this.children.forEach((child) => child.doForAll(fn));\\n      }\\n    });\\n  }\\n\\n  expandAll() {\\n    this.doForAll((node) => node.expand());\\n  }\\n\\n  collapseAll() {\\n    this.doForAll((node) => node.collapse());\\n  }\\n\\n  ensureVisible() {\\n    if (this.realParent) {\\n      this.realParent.expand();\\n      this.realParent.ensureVisible();\\n    }\\n\\n    return this;\\n  }\\n\\n  toggleExpanded() {\\n    this.setIsExpanded(!this.isExpanded);\\n\\n    return this;\\n  }\\n\\n  setIsExpanded(value) {\\n    if (this.hasChildren) {\\n      this.treeModel.setExpandedNode(this, value);\\n    }\\n\\n    return this;\\n  };\\n\\n  autoLoadChildren() {\\n    this.handler =\\n      reaction(\\n        () => this.isExpanded,\\n        (isExpanded) => {\\n          if (!this.children && this.hasChildren && isExpanded) {\\n            this.loadNodeChildren();\\n          }\\n        },\\n        { fireImmediately: true }\\n      );\\n  }\\n\\n  dispose() {\\n    if (this.children) {\\n      this.children.forEach((child) => child.dispose());\\n    }\\n    if (this.handler) {\\n      this.handler();\\n    }\\n    this.parent = null;\\n    this.children = null;\\n  }\\n\\n  setIsActive(value, multi = false) {\\n    this.treeModel.setActiveNode(this, value, multi);\\n    if (value) {\\n      this.focus(this.options.scrollOnActivate);\\n    }\\n\\n    return this;\\n  }\\n\\n  isSelectable() {\\n    return this.isLeaf || !this.children || !this.options.useTriState;\\n  }\\n\\n  @action setIsSelected(value) {\\n    if (this.isSelectable()) {\\n      this.treeModel.setSelectedNode(this, value);\\n    } else {\\n      this.visibleChildren.forEach((child) => child.setIsSelected(value));\\n    }\\n\\n    return this;\\n  }\\n\\n  toggleSelected() {\\n    this.setIsSelected(!this.isSelected);\\n\\n    return this;\\n  }\\n\\n  toggleActivated(multi = false) {\\n    this.setIsActive(!this.isActive, multi);\\n\\n    return this;\\n  }\\n\\n  setActiveAndVisible(multi = false) {\\n    this.setIsActive(true, multi)\\n      .ensureVisible();\\n\\n    setTimeout(this.scrollIntoView.bind(this));\\n\\n    return this;\\n  }\\n\\n  scrollIntoView(force = false) {\\n    this.treeModel.virtualScroll.scrollIntoView(this, force);\\n  }\\n\\n  focus(scroll = true) {\\n    let previousNode = this.treeModel.getFocusedNode();\\n    this.treeModel.setFocusedNode(this);\\n    if (scroll) {\\n      this.scrollIntoView();\\n    }\\n    if (previousNode) {\\n      this.fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });\\n    }\\n    this.fireEvent({ eventName: TREE_EVENTS.focus, node: this });\\n\\n    return this;\\n  }\\n\\n  blur() {\\n    let previousNode = this.treeModel.getFocusedNode();\\n    this.treeModel.setFocusedNode(null);\\n    if (previousNode) {\\n      this.fireEvent({ eventName: TREE_EVENTS.blur, node: this });\\n    }\\n\\n    return this;\\n  }\\n\\n  setIsHidden(value) {\\n    this.treeModel.setIsHidden(this, value);\\n  }\\n\\n  hide() {\\n    this.setIsHidden(true);\\n  }\\n\\n  show() {\\n    this.setIsHidden(false);\\n  }\\n\\n  mouseAction(actionName: string, $event, data: any = null) {\\n    this.treeModel.setFocus(true);\\n\\n    const actionMapping = this.options.actionMapping.mouse;\\n    const mouseAction = actionMapping[actionName];\\n\\n    if (mouseAction) {\\n      mouseAction(this.treeModel, this, $event, data);\\n    }\\n  }\\n\\n  getSelfHeight() {\\n    return this.options.nodeHeight(this);\\n  }\\n\\n  @action _initChildren() {\\n    this.children = this.getField('children')\\n      .map((c, index) => new TreeNode(c, this, this.treeModel, index));\\n  }\\n}\\n\\nfunction uuid() {\\n  return Math.floor(Math.random() * 10000000000000);\\n}\\n\",\"import { Injectable, OnDestroy } from '@angular/core';\\nimport { observable, computed, action, autorun } from 'mobx';\\nimport { Subscription } from 'rxjs';\\nimport { TreeNode } from './tree-node.model';\\nimport { TreeOptions } from './tree-options.model';\\nimport { TreeVirtualScroll } from './tree-virtual-scroll.model';\\nimport { ITreeModel, IDType, IDTypeDictionary } from '../defs/api';\\nimport { TREE_EVENTS } from '../constants/events';\\n\\n@Injectable()\\nexport class TreeModel implements ITreeModel, OnDestroy {\\n  static focusedTree = null;\\n\\n  options: TreeOptions = new TreeOptions();\\n  nodes: any[];\\n  eventNames = Object.keys(TREE_EVENTS);\\n  virtualScroll: TreeVirtualScroll;\\n\\n  @observable roots: TreeNode[];\\n  @observable expandedNodeIds: IDTypeDictionary = {};\\n  @observable selectedLeafNodeIds: IDTypeDictionary = {};\\n  @observable activeNodeIds: IDTypeDictionary = {};\\n  @observable hiddenNodeIds: IDTypeDictionary = {};\\n  @observable focusedNodeId: IDType = null;\\n  @observable virtualRoot: TreeNode;\\n\\n  private firstUpdate = true;\\n  private events: any;\\n  private subscriptions: Subscription[] = [];\\n\\n  // events\\n  fireEvent(event) {\\n    event.treeModel = this;\\n    this.events[event.eventName].emit(event);\\n    this.events.event.emit(event);\\n  }\\n\\n  subscribe(eventName, fn) {\\n    const subscription = this.events[eventName].subscribe(fn);\\n    this.subscriptions.push(subscription);\\n  }\\n\\n\\n  // getters\\n  getFocusedNode(): TreeNode {\\n    return this.focusedNode;\\n  }\\n\\n\\n  getActiveNode(): TreeNode {\\n    return this.activeNodes[0];\\n  }\\n\\n  getActiveNodes(): TreeNode[] {\\n    return this.activeNodes;\\n  }\\n\\n  getVisibleRoots() {\\n    return this.virtualRoot.visibleChildren;\\n  }\\n\\n  getFirstRoot(skipHidden = false) {\\n    const root = skipHidden ? this.getVisibleRoots() : this.roots;\\n    return root != null && root.length ? root[0] : null;\\n  }\\n\\n  getLastRoot(skipHidden = false) {\\n    const root = skipHidden ? this.getVisibleRoots() : this.roots;\\n    return root != null && root.length ? root[root.length - 1] : null;\\n  }\\n\\n  get isFocused() {\\n    return TreeModel.focusedTree === this;\\n  }\\n\\n  isNodeFocused(node) {\\n    return this.focusedNode === node;\\n  }\\n\\n  isEmptyTree(): boolean {\\n    return this.roots && this.roots.length === 0;\\n  }\\n\\n  @computed get focusedNode() {\\n    return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;\\n  }\\n\\n  @computed get expandedNodes() {\\n    const nodes = Object.keys(this.expandedNodeIds)\\n      .filter((id) => this.expandedNodeIds[id])\\n      .map((id) => this.getNodeById(id));\\n\\n    return nodes.filter(Boolean);\\n  }\\n\\n  @computed get activeNodes() {\\n    const nodes = Object.keys(this.activeNodeIds)\\n      .filter((id) => this.activeNodeIds[id])\\n      .map((id) => this.getNodeById(id));\\n\\n    return nodes.filter(Boolean);\\n  }\\n\\n  @computed get hiddenNodes() {\\n    const nodes = Object.keys(this.hiddenNodeIds)\\n        .filter((id) => this.hiddenNodeIds[id])\\n        .map((id) => this.getNodeById(id));\\n\\n    return nodes.filter(Boolean);\\n  }\\n\\n  @computed get selectedLeafNodes() {\\n    const nodes = Object.keys(this.selectedLeafNodeIds)\\n        .filter((id) => this.selectedLeafNodeIds[id])\\n        .map((id) => this.getNodeById(id));\\n\\n    return nodes.filter(Boolean);\\n  }\\n\\n  // locating nodes\\n  getNodeByPath(path: any[], startNode= null): TreeNode {\\n    if (!path) return null;\\n\\n    startNode = startNode || this.virtualRoot;\\n    if (path.length === 0) return startNode;\\n\\n    if (!startNode.children) return null;\\n\\n    const childId = path.shift();\\n    const childNode = startNode.children.find(c => c.id === childId);\\n\\n    if (!childNode) return null;\\n\\n    return this.getNodeByPath(path, childNode);\\n  }\\n\\n  getNodeById(id) {\\n    const idStr = id.toString();\\n\\n    return this.getNodeBy((node) => node.id.toString() === idStr);\\n  }\\n\\n  getNodeBy(predicate, startNode = null) {\\n    startNode = startNode || this.virtualRoot;\\n\\n    if (!startNode.children) return null;\\n\\n    const found = startNode.children.find(predicate);\\n\\n    if (found) { // found in children\\n      return found;\\n    } else { // look in children's children\\n      for (let child of startNode.children) {\\n        const foundInChildren = this.getNodeBy(predicate, child);\\n        if (foundInChildren) return foundInChildren;\\n      }\\n    }\\n  }\\n\\n  isExpanded(node) {\\n    return this.expandedNodeIds[node.id];\\n  }\\n\\n  isHidden(node) {\\n    return this.hiddenNodeIds[node.id];\\n  }\\n\\n  isActive(node) {\\n    return this.activeNodeIds[node.id];\\n  }\\n\\n  isSelected(node) {\\n    return this.selectedLeafNodeIds[node.id];\\n  }\\n\\n  ngOnDestroy() {\\n    this.dispose();\\n    this.unsubscribeAll();\\n  }\\n\\n  dispose() {\\n    // Dispose reactions of the replaced nodes\\n    if (this.virtualRoot) {\\n      this.virtualRoot.dispose();\\n    }\\n  }\\n\\n  unsubscribeAll() {\\n    this.subscriptions.forEach(subscription => subscription.unsubscribe());\\n    this.subscriptions = [];\\n  }\\n\\n  // actions\\n  @action setData({ nodes, options = null, events = null }: {nodes: any, options: any, events: any}) {\\n    if (options) {\\n      this.options = new TreeOptions(options);\\n    }\\n    if (events) {\\n      this.events = events;\\n    }\\n    if (nodes) {\\n      this.nodes = nodes;\\n    }\\n\\n    this.update();\\n  }\\n\\n  @action update() {\\n    // Rebuild tree:\\n    let virtualRootConfig = {\\n      id: this.options.rootId,\\n      virtual: true,\\n      [this.options.childrenField]: this.nodes\\n    };\\n\\n    this.dispose();\\n\\n    this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);\\n\\n    this.roots = this.virtualRoot.children;\\n\\n    // Fire event:\\n    if (this.firstUpdate) {\\n      if (this.roots) {\\n        this.firstUpdate = false;\\n        this._calculateExpandedNodes();\\n      }\\n    } else {\\n      this.fireEvent({ eventName: TREE_EVENTS.updateData });\\n    }\\n  }\\n\\n\\n  @action setFocusedNode(node) {\\n    this.focusedNodeId = node ? node.id : null;\\n  }\\n\\n  @action setFocus(value) {\\n    TreeModel.focusedTree = value ? this : null;\\n  }\\n\\n  @action doForAll(fn) {\\n    this.roots.forEach((root) => root.doForAll(fn));\\n  }\\n\\n  @action focusNextNode() {\\n    let previousNode = this.getFocusedNode();\\n    let nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);\\n    if (nextNode) nextNode.focus();\\n  }\\n\\n  @action focusPreviousNode() {\\n    let previousNode = this.getFocusedNode();\\n    let nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);\\n    if (nextNode) nextNode.focus();\\n  }\\n\\n  @action focusDrillDown() {\\n    let previousNode = this.getFocusedNode();\\n    if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {\\n      previousNode.toggleExpanded();\\n    }\\n    else {\\n      let nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);\\n      if (nextNode) nextNode.focus();\\n    }\\n  }\\n\\n  @action focusDrillUp() {\\n    let previousNode = this.getFocusedNode();\\n    if (!previousNode) return;\\n    if (previousNode.isExpanded) {\\n      previousNode.toggleExpanded();\\n    }\\n    else {\\n      let nextNode = previousNode.realParent;\\n      if (nextNode) nextNode.focus();\\n    }\\n  }\\n\\n  @action setActiveNode(node, value, multi = false) {\\n    if (multi) {\\n      this._setActiveNodeMulti(node, value);\\n    }\\n    else {\\n      this._setActiveNodeSingle(node, value);\\n    }\\n\\n    if (value) {\\n      node.focus(this.options.scrollOnActivate);\\n      this.fireEvent({ eventName: TREE_EVENTS.activate, node });\\n      this.fireEvent({ eventName: TREE_EVENTS.nodeActivate, node }); // For IE11\\n    } else {\\n      this.fireEvent({ eventName: TREE_EVENTS.deactivate, node });\\n      this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node }); // For IE11\\n    }\\n  }\\n\\n  @action setSelectedNode(node, value) {\\n    this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, {[node.id]: value});\\n\\n    if (value) {\\n      node.focus();\\n      this.fireEvent({ eventName: TREE_EVENTS.select, node });\\n    } else {\\n      this.fireEvent({ eventName: TREE_EVENTS.deselect, node });\\n    }\\n  }\\n\\n  @action setExpandedNode(node, value) {\\n    this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, {[node.id]: value});\\n    this.fireEvent({ eventName: TREE_EVENTS.toggleExpanded, node, isExpanded: value });\\n  }\\n\\n  @action expandAll() {\\n    this.roots.forEach((root) => root.expandAll());\\n  }\\n\\n  @action collapseAll() {\\n    this.roots.forEach((root) => root.collapseAll());\\n  }\\n\\n  @action setIsHidden(node, value) {\\n    this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, {[node.id]: value});\\n  }\\n\\n  @action setHiddenNodeIds(nodeIds) {\\n    this.hiddenNodeIds = nodeIds.reduce((hiddenNodeIds, id) => Object.assign(hiddenNodeIds, {\\n      [id]: true\\n    }), {});\\n  }\\n\\n  performKeyAction(node, $event) {\\n    const keyAction = this.options.actionMapping.keys[$event.keyCode];\\n    if (keyAction) {\\n      $event.preventDefault();\\n      keyAction(this, node, $event);\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  @action filterNodes(filter, autoShow = true) {\\n    let filterFn;\\n\\n    if (!filter) {\\n      return this.clearFilter();\\n    }\\n\\n    // support function and string filter\\n    if (filter && typeof filter.valueOf() === 'string') {\\n      filterFn = (node) => node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1;\\n    }\\n    else if (filter && typeof filter === 'function') {\\n       filterFn = filter;\\n    }\\n    else {\\n      console.error('Don\\\\'t know what to do with filter', filter);\\n      console.error('Should be either a string or function');\\n      return;\\n    }\\n\\n    const ids = {};\\n    this.roots.forEach((node) => this._filterNode(ids, node, filterFn, autoShow));\\n    this.hiddenNodeIds = ids;\\n    this.fireEvent({ eventName: TREE_EVENTS.changeFilter });\\n  }\\n\\n  @action clearFilter() {\\n    this.hiddenNodeIds = {};\\n    this.fireEvent({ eventName: TREE_EVENTS.changeFilter });\\n  }\\n\\n  @action moveNode(node, to) {\\n    const fromIndex = node.getIndexInParent();\\n    const fromParent = node.parent;\\n\\n    if (!this.canMoveNode(node, to, fromIndex)) return;\\n\\n    const fromChildren = fromParent.getField('children');\\n\\n    // If node doesn't have children - create children array\\n    if (!to.parent.getField('children')) {\\n      to.parent.setField('children', []);\\n    }\\n    const toChildren = to.parent.getField('children');\\n\\n    const originalNode = fromChildren.splice(fromIndex, 1)[0];\\n\\n    // Compensate for index if already removed from parent:\\n    let toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;\\n\\n    toChildren.splice(toIndex, 0, originalNode);\\n\\n    fromParent.treeModel.update();\\n    if (to.parent.treeModel !== fromParent.treeModel) {\\n      to.parent.treeModel.update();\\n    }\\n\\n    this.fireEvent({\\n      eventName: TREE_EVENTS.moveNode,\\n      node: originalNode,\\n      to: { parent: to.parent.data, index: toIndex },\\n      from: { parent: fromParent.data, index: fromIndex}\\n    });\\n  }\\n\\n  @action copyNode(node, to) {\\n    const fromIndex = node.getIndexInParent();\\n\\n    if (!this.canMoveNode(node, to, fromIndex)) return;\\n\\n    // If node doesn't have children - create children array\\n    if (!to.parent.getField('children')) {\\n      to.parent.setField('children', []);\\n    }\\n    const toChildren = to.parent.getField('children');\\n\\n    const nodeCopy = this.options.getNodeClone(node);\\n\\n    toChildren.splice(to.index, 0, nodeCopy);\\n\\n    node.treeModel.update();\\n    if (to.parent.treeModel !== node.treeModel) {\\n      to.parent.treeModel.update();\\n    }\\n\\n    this.fireEvent({ eventName: TREE_EVENTS.copyNode, node: nodeCopy, to: { parent: to.parent.data, index: to.index } });\\n  }\\n\\n  getState() {\\n    return {\\n      expandedNodeIds: this.expandedNodeIds,\\n      selectedLeafNodeIds: this.selectedLeafNodeIds,\\n      activeNodeIds: this.activeNodeIds,\\n      hiddenNodeIds: this.hiddenNodeIds,\\n      focusedNodeId: this.focusedNodeId\\n    };\\n  }\\n\\n  @action setState(state) {\\n    if (!state) return;\\n\\n    Object.assign(this, {\\n      expandedNodeIds: state.expandedNodeIds || {},\\n      selectedLeafNodeIds: state.selectedLeafNodeIds || {},\\n      activeNodeIds: state.activeNodeIds || {},\\n      hiddenNodeIds: state.hiddenNodeIds || {},\\n      focusedNodeId: state.focusedNodeId\\n    });\\n  }\\n\\n  subscribeToState(fn) {\\n    autorun(() => fn(this.getState()));\\n  }\\n\\n  canMoveNode(node, to, fromIndex = undefined) {\\n    const fromNodeIndex = fromIndex || node.getIndexInParent();\\n\\n    // same node:\\n    if (node.parent === to.parent && fromIndex === to.index) {\\n      return false;\\n    }\\n\\n    return !to.parent.isDescendantOf(node);\\n  }\\n\\n  calculateExpandedNodes() {\\n      this._calculateExpandedNodes();\\n  }\\n\\n  // private methods\\n  private _filterNode(ids, node, filterFn, autoShow) {\\n    // if node passes function then it's visible\\n    let isVisible = filterFn(node);\\n\\n    if (node.children) {\\n      // if one of node's children passes filter then this node is also visible\\n      node.children.forEach((child) => {\\n        if (this._filterNode(ids, child, filterFn, autoShow)) {\\n          isVisible = true;\\n        }\\n      });\\n    }\\n\\n    // mark node as hidden\\n    if (!isVisible) {\\n      ids[node.id] = true;\\n    }\\n    // auto expand parents to make sure the filtered nodes are visible\\n    if (autoShow && isVisible) {\\n      node.ensureVisible();\\n    }\\n    return isVisible;\\n  }\\n\\n  private _calculateExpandedNodes(startNode = null) {\\n    startNode = startNode || this.virtualRoot;\\n\\n    if (startNode.data[this.options.isExpandedField]) {\\n      this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, {[startNode.id]: true});\\n    }\\n    if (startNode.children) {\\n      startNode.children.forEach((child) => this._calculateExpandedNodes(child));\\n    }\\n  }\\n\\n  private _setActiveNodeSingle(node, value) {\\n    // Deactivate all other nodes:\\n    this.activeNodes\\n      .filter((activeNode) => activeNode !== node)\\n      .forEach((activeNode) => {\\n        this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });\\n        this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node: activeNode }); // For IE11\\n      });\\n\\n    if (value) {\\n      this.activeNodeIds = {[node.id]: true};\\n    }\\n    else {\\n      this.activeNodeIds = {};\\n    }\\n  }\\n\\n  private _setActiveNodeMulti(node, value) {\\n    this.activeNodeIds = Object.assign({}, this.activeNodeIds, {[node.id]: value});\\n  }\\n\\n}\\n\",\"import { Injectable } from '@angular/core';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class TreeDraggedElement {\\n  _draggedElement: any = null;\\n\\n  set(draggedElement: any) {\\n    this._draggedElement = draggedElement;\\n  }\\n\\n  get(): any {\\n    return this._draggedElement;\\n  }\\n\\n  isDragging() {\\n    return !!this.get();\\n  }\\n}\\n\",\"import { Injectable } from '@angular/core';\\nimport { observable, computed, action, autorun, reaction } from 'mobx';\\nimport { TreeModel } from './tree.model';\\nimport { TREE_EVENTS } from '../constants/events';\\n\\nconst Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\\nconst Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\\n\\n@Injectable()\\nexport class TreeVirtualScroll {\\n  private _dispose: any;\\n\\n  @observable yBlocks = 0;\\n  @observable x = 0;\\n  @observable viewportHeight = null;\\n  viewport = null;\\n\\n  @computed get y() {\\n    return this.yBlocks * Y_EPSILON;\\n  }\\n\\n  @computed get totalHeight() {\\n    return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\\n  }\\n\\n  constructor(private treeModel: TreeModel) {\\n    treeModel.virtualScroll = this;\\n    this._dispose = [autorun(() => this.fixScroll())];\\n  }\\n\\n  fireEvent(event) {\\n    this.treeModel.fireEvent(event);\\n  }\\n\\n  init() {\\n    const fn = this.recalcPositions.bind(this);\\n\\n    fn();\\n    this._dispose = [\\n      ...this._dispose,\\n      reaction(() => this.treeModel.roots, fn),\\n      reaction(() => this.treeModel.expandedNodeIds, fn),\\n      reaction(() => this.treeModel.hiddenNodeIds, fn)\\n    ];\\n    this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\\n  }\\n\\n  isEnabled() {\\n    return this.treeModel.options.useVirtualScroll;\\n  }\\n\\n  @action private _setYBlocks(value) {\\n    this.yBlocks = value;\\n  }\\n\\n  @action recalcPositions() {\\n    this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\\n  }\\n\\n  private _getPositionAfter(nodes, startPos) {\\n    let position = startPos;\\n\\n    nodes.forEach((node) => {\\n      node.position = position;\\n      position = this._getPositionAfterNode(node, position);\\n    });\\n    return position;\\n  }\\n\\n  private _getPositionAfterNode(node, startPos) {\\n    let position = node.getSelfHeight() + startPos;\\n\\n    if (node.children && node.isExpanded) { // TBD: consider loading component as well\\n      position = this._getPositionAfter(node.visibleChildren, position);\\n    }\\n    node.height = position - startPos;\\n    return position;\\n  }\\n\\n\\n  clear() {\\n    this._dispose.forEach((d) => d());\\n  }\\n\\n  @action setViewport(viewport) {\\n    Object.assign(this, {\\n      viewport,\\n      x: viewport.scrollLeft,\\n      yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\\n      viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\\n    });\\n  }\\n\\n  @action scrollIntoView(node, force, scrollToMiddle = true) {\\n    if (node.options.scrollContainer) {\\n      const scrollContainer = node.options.scrollContainer;\\n      const scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\\n      const scrollContainerTop = scrollContainer.getBoundingClientRect().top;\\n      const nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\\n\\n      if (force || // force scroll to node\\n        nodeTop < scrollContainer.scrollTop || // node is above scroll container\\n        nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) { // node is below container\\n        scrollContainer.scrollTop = scrollToMiddle ?\\n          nodeTop - scrollContainerHeight / 2 : // scroll to middle\\n          nodeTop; // scroll to start\\n      }\\n    } else {\\n      if (force || // force scroll to node\\n        node.position < this.y || // node is above viewport\\n        node.position + node.getSelfHeight() > this.y + this.viewportHeight) { // node is below viewport\\n        if (this.viewport) {\\n          this.viewport.scrollTop = scrollToMiddle ?\\n          node.position - this.viewportHeight / 2 : // scroll to middle\\n          node.position; // scroll to start\\n\\n          this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\\n        }\\n      }\\n    }\\n  }\\n\\n  getViewportNodes(nodes) {\\n    if (!nodes) return [];\\n\\n    const visibleNodes = nodes.filter((node) => !node.isHidden);\\n\\n    if (!this.isEnabled()) return visibleNodes;\\n\\n    if (!this.viewportHeight || !visibleNodes.length) return [];\\n\\n    // When loading children async this method is called before their height and position is calculated.\\n    // In that case firstIndex === 0 and lastIndex === visibleNodes.length - 1 (e.g. 1000),\\n    // which means that it loops through every visibleNodes item and push them into viewportNodes array.\\n    // We can prevent nodes from being pushed to the array and wait for the appropriate calculations to take place\\n    const lastVisibleNode = visibleNodes.slice(-1)[0]\\n    if (!lastVisibleNode.height && lastVisibleNode.position === 0) return [];\\n\\n    // Search for first node in the viewport using binary search\\n    // Look for first node that starts after the beginning of the viewport (with buffer)\\n    // Or that ends after the beginning of the viewport\\n    const firstIndex = binarySearch(visibleNodes, (node) => {\\n      return (node.position + Y_OFFSET > this.y) ||\\n             (node.position + node.height > this.y);\\n    });\\n\\n    // Search for last node in the viewport using binary search\\n    // Look for first node that starts after the end of the viewport (with buffer)\\n    const lastIndex = binarySearch(visibleNodes, (node) => {\\n      return node.position - Y_OFFSET > this.y + this.viewportHeight;\\n    }, firstIndex);\\n\\n    const viewportNodes = [];\\n\\n    for (let i = firstIndex; i <= lastIndex; i++) {\\n      viewportNodes.push(visibleNodes[i]);\\n    }\\n\\n    return viewportNodes;\\n  }\\n\\n  fixScroll() {\\n    const maxY = Math.max(0, this.totalHeight - this.viewportHeight);\\n\\n    if (this.y < 0) this._setYBlocks(0);\\n    if (this.y > maxY) this._setYBlocks(maxY / Y_EPSILON);\\n  }\\n}\\n\\nfunction binarySearch(nodes, condition, firstIndex = 0) {\\n  let index = firstIndex;\\n  let toIndex = nodes.length - 1;\\n\\n  while (index !== toIndex) {\\n    let midIndex = Math.floor((index + toIndex) / 2);\\n\\n    if (condition(nodes[midIndex])) {\\n      toIndex = midIndex;\\n    }\\n    else {\\n      if (index === midIndex) index = toIndex;\\n      else index = midIndex;\\n    }\\n  }\\n  return index;\\n}\\n\",\"import { Component, Input, TemplateRef, ViewEncapsulation } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  encapsulation: ViewEncapsulation.None,\\n  selector: 'tree-loading-component',\\n  template: `\\n    <span *ngIf=\\\"!template\\\">loading...</span>\\n    <ng-container\\n      [ngTemplateOutlet]=\\\"template\\\"\\n      [ngTemplateOutletContext]=\\\"{ $implicit: node }\\\">\\n    </ng-container>\\n  `,\\n})\\nexport class LoadingComponent {\\n  @Input() template: TemplateRef<any>;\\n  @Input() node: TreeNode;\\n}\\n\",\"import {\\n  Component,\\n  ElementRef,\\n  AfterViewInit,\\n  OnInit,\\n  OnDestroy,\\n} from '@angular/core';\\nimport { TreeVirtualScroll } from '../models/tree-virtual-scroll.model';\\nimport { TREE_EVENTS } from '../constants/events';\\n\\n@Component({\\n  selector: 'tree-viewport',\\n  styles: [],\\n  providers: [TreeVirtualScroll],\\n  template: `\\n    <ng-container *treeMobxAutorun=\\\"{ dontDetach: true }\\\">\\n      <div [style.height]=\\\"getTotalHeight()\\\">\\n        <ng-content></ng-content>\\n      </div>\\n    </ng-container>\\n  `\\n})\\nexport class TreeViewportComponent implements AfterViewInit, OnInit, OnDestroy {\\n  setViewport = this.throttle(() => {\\n    this.virtualScroll.setViewport(this.elementRef.nativeElement);\\n  }, 17);\\n\\n  private readonly scrollEventHandler: ($event: Event) => void;\\n\\n  constructor(\\n    private elementRef: ElementRef,\\n    public virtualScroll: TreeVirtualScroll\\n  ) {\\n    this.scrollEventHandler = this.setViewport.bind(this);\\n  }\\n\\n  ngOnInit() {\\n    this.virtualScroll.init();\\n  }\\n\\n  ngAfterViewInit() {\\n    setTimeout(() => {\\n      this.setViewport();\\n      this.virtualScroll.fireEvent({ eventName: TREE_EVENTS.initialized });\\n    });\\n    let el: HTMLElement = this.elementRef.nativeElement;\\n    el.addEventListener('scroll', this.scrollEventHandler);\\n  }\\n\\n  ngOnDestroy() {\\n    this.virtualScroll.clear();\\n    let el: HTMLElement = this.elementRef.nativeElement;\\n    el.removeEventListener('scroll', this.scrollEventHandler);\\n  }\\n\\n  getTotalHeight() {\\n    return (\\n      (this.virtualScroll.isEnabled() &&\\n        this.virtualScroll.totalHeight + 'px') ||\\n      'auto'\\n    );\\n  }\\n\\n  private throttle(func, timeFrame) {\\n    let lastTime = 0;\\n    return function () {\\n      let now = Date.now();\\n      if (now - lastTime >= timeFrame) {\\n        func();\\n        lastTime = now;\\n      }\\n    };\\n  }\\n}\\n\",\"import {\\n  AfterViewInit,\\n  Directive,\\n  ElementRef,\\n  EventEmitter,\\n  HostListener,\\n  Input,\\n  NgZone,\\n  OnDestroy,\\n  Output,\\n  Renderer2\\n} from '@angular/core';\\nimport { TreeDraggedElement } from '../models/tree-dragged-element.model';\\n\\nconst DRAG_OVER_CLASS = 'is-dragging-over';\\nconst DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';\\n\\n@Directive({\\n  selector: '[treeDrop]'\\n})\\nexport class TreeDropDirective implements AfterViewInit, OnDestroy {\\n  @Input() allowDragoverStyling = true;\\n  @Output('treeDrop') onDropCallback = new EventEmitter();\\n  @Output('treeDropDragOver') onDragOverCallback = new EventEmitter();\\n  @Output('treeDropDragLeave') onDragLeaveCallback = new EventEmitter();\\n  @Output('treeDropDragEnter') onDragEnterCallback = new EventEmitter();\\n  private readonly dragOverEventHandler: (ev: DragEvent) => void;\\n  private readonly dragEnterEventHandler: (ev: DragEvent) => void;\\n  private readonly dragLeaveEventHandler: (ev: DragEvent) => void;\\n\\n  private _allowDrop = (element, $event) => true;\\n\\n  @Input() set treeAllowDrop(allowDrop) {\\n    if (allowDrop instanceof Function) {\\n      this._allowDrop = allowDrop;\\n    }\\n    else this._allowDrop = (element, $event) => allowDrop;\\n  }\\n\\n  allowDrop($event) {\\n    return this._allowDrop(this.treeDraggedElement.get(), $event);\\n  }\\n\\n  constructor(private el: ElementRef, private renderer: Renderer2, private treeDraggedElement: TreeDraggedElement, private ngZone: NgZone) {\\n    this.dragOverEventHandler = this.onDragOver.bind(this);\\n    this.dragEnterEventHandler = this.onDragEnter.bind(this);\\n    this.dragLeaveEventHandler = this.onDragLeave.bind(this);\\n  }\\n\\n  ngAfterViewInit() {\\n    let el: HTMLElement = this.el.nativeElement;\\n    this.ngZone.runOutsideAngular(() => {\\n      el.addEventListener('dragover', this.dragOverEventHandler);\\n      el.addEventListener('dragenter', this.dragEnterEventHandler);\\n      el.addEventListener('dragleave', this.dragLeaveEventHandler);\\n    });\\n  }\\n\\n  ngOnDestroy() {\\n    let el: HTMLElement = this.el.nativeElement;\\n    el.removeEventListener('dragover', this.dragOverEventHandler);\\n    el.removeEventListener('dragenter', this.dragEnterEventHandler);\\n    el.removeEventListener('dragleave', this.dragLeaveEventHandler);\\n  }\\n\\n  onDragOver($event) {\\n    if (!this.allowDrop($event)) {\\n      if (this.allowDragoverStyling) {\\n        return this.addDisabledClass();\\n      }\\n      return;\\n    }\\n\\n    this.onDragOverCallback.emit({event: $event, element: this.treeDraggedElement.get()});\\n\\n    $event.preventDefault();\\n    if (this.allowDragoverStyling) {\\n      this.addClass();\\n    }\\n  }\\n\\n  onDragEnter($event) {\\n    if (!this.allowDrop($event)) return;\\n\\n    $event.preventDefault();\\n    this.onDragEnterCallback.emit({event: $event, element: this.treeDraggedElement.get()});\\n  }\\n\\n  onDragLeave($event) {\\n    if (!this.allowDrop($event)) {\\n      if (this.allowDragoverStyling) {\\n        return this.removeDisabledClass();\\n      }\\n      return;\\n    }\\n    this.onDragLeaveCallback.emit({event: $event, element: this.treeDraggedElement.get()});\\n\\n    if (this.allowDragoverStyling) {\\n      this.removeClass();\\n    }\\n  }\\n\\n  @HostListener('drop', ['$event']) onDrop($event) {\\n    if (!this.allowDrop($event)) return;\\n\\n    $event.preventDefault();\\n    this.onDropCallback.emit({event: $event, element: this.treeDraggedElement.get()});\\n\\n    if (this.allowDragoverStyling) {\\n      this.removeClass();\\n    }\\n    this.treeDraggedElement.set(null);\\n  }\\n\\n  private addClass() {\\n    this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);\\n  }\\n\\n  private removeClass() {\\n    this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);\\n  }\\n\\n  private addDisabledClass() {\\n    this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\\n  }\\n\\n  private removeDisabledClass() {\\n    this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\\n  }\\n}\\n\",\"import { Component, Input, ViewEncapsulation } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'TreeNodeDropSlot, tree-node-drop-slot',\\n  encapsulation: ViewEncapsulation.None,\\n  styles: [],\\n  template: `\\n    <div\\n      class=\\\"node-drop-slot\\\"\\n      (treeDrop)=\\\"onDrop($event)\\\"\\n      [treeAllowDrop]=\\\"allowDrop.bind(this)\\\"\\n      [allowDragoverStyling]=\\\"true\\\">\\n    </div>\\n  `\\n})\\nexport class TreeNodeDropSlot {\\n  @Input() node: TreeNode;\\n  @Input() dropIndex: number;\\n\\n  onDrop($event) {\\n    this.node.mouseAction('drop', $event.event, {\\n      from: $event.element,\\n      to: { parent: this.node, index: this.dropIndex }\\n    });\\n  }\\n\\n  allowDrop(element, $event) {\\n    return this.node.options.allowDrop(element, { parent: this.node, index: this.dropIndex }, $event);\\n  }\\n}\\n\",\"import { action as mobxAction } from 'mobx';\\nimport { computed as mobxComputed } from 'mobx';\\nimport { observable as mobxObservable } from 'mobx';\\n\\n// Re-export mobx operators to be able to use inside components with AOT:\\nexport function actionInternal(...args) {\\n  return (mobxAction as any)(...args);\\n}\\nexport const action: typeof mobxAction = Object.assign(\\n  actionInternal,\\n  mobxAction\\n) as any;\\n\\nfunction computedInternal(...args) {\\n  return (mobxComputed as any)(...args);\\n}\\nexport const computed: typeof mobxComputed = Object.assign(\\n  computedInternal,\\n  mobxComputed\\n) as any;\\n\\nfunction observableInternal(...args) {\\n  return (mobxObservable as any)(...args);\\n}\\n\\nexport const observable: typeof mobxObservable = Object.assign(\\n  observableInternal,\\n  mobxObservable\\n) as any;\\n\",\"import {\\n  Component,\\n  Input,\\n  ViewEncapsulation,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport { reaction } from 'mobx';\\nimport { observable, computed, action } from '../mobx-angular/mobx-proxy';\\nimport { TreeVirtualScroll } from '../models/tree-virtual-scroll.model';\\nimport { TreeNode } from '../models/tree-node.model';\\nimport { TreeModel } from '../models/tree.model';\\n\\n@Component({\\n  selector: 'tree-node-collection',\\n  encapsulation: ViewEncapsulation.None,\\n  template: `\\n    <ng-container *treeMobxAutorun=\\\"{ dontDetach: true }\\\">\\n      <div [style.margin-top]=\\\"marginTop\\\">\\n        <tree-node\\n          *ngFor=\\\"let node of viewportNodes; let i = index; trackBy: trackNode\\\"\\n          [node]=\\\"node\\\"\\n          [index]=\\\"i\\\"\\n          [templates]=\\\"templates\\\"\\n        >\\n        </tree-node>\\n      </div>\\n    </ng-container>\\n  `\\n})\\nexport class TreeNodeCollectionComponent implements OnInit, OnDestroy {\\n  @Input()\\n  get nodes() {\\n    return this._nodes;\\n  }\\n  set nodes(nodes) {\\n    this.setNodes(nodes);\\n  }\\n\\n  @Input() treeModel: TreeModel;\\n\\n  @observable _nodes;\\n  private virtualScroll: TreeVirtualScroll; // Cannot inject this, because we might be inside treeNodeTemplateFull\\n  @Input() templates;\\n\\n  @observable viewportNodes: TreeNode[];\\n\\n  @computed get marginTop(): string {\\n    const firstNode =\\n      this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];\\n    const relativePosition =\\n      firstNode && firstNode.parent\\n        ? firstNode.position -\\n          firstNode.parent.position -\\n          firstNode.parent.getSelfHeight()\\n        : 0;\\n\\n    return `${relativePosition}px`;\\n  }\\n\\n  _dispose = [];\\n\\n  @action setNodes(nodes) {\\n    this._nodes = nodes;\\n  }\\n\\n  ngOnInit() {\\n    this.virtualScroll = this.treeModel.virtualScroll;\\n    this._dispose = [\\n      // return node indexes so we can compare structurally,\\n      reaction(\\n        () => {\\n          return this.virtualScroll\\n            .getViewportNodes(this.nodes)\\n            .map(n => n.index);\\n        },\\n        nodeIndexes => {\\n          this.viewportNodes = nodeIndexes.map(i => this.nodes[i]);\\n        },\\n        { compareStructural: true, fireImmediately: true } as any\\n      ),\\n      reaction(\\n        () => this.nodes,\\n        nodes => {\\n          this.viewportNodes = this.virtualScroll.getViewportNodes(nodes);\\n        }\\n      )\\n    ];\\n  }\\n\\n  ngOnDestroy() {\\n    this._dispose.forEach(d => d());\\n  }\\n\\n  trackNode(index, node) {\\n    return node.id;\\n  }\\n}\\n\",\"import { Component, ContentChild, EventEmitter, HostListener, Input, OnChanges, Output, TemplateRef, ViewChild } from '@angular/core';\\nimport { TreeModel } from '../models/tree.model';\\nimport { TreeDraggedElement } from '../models/tree-dragged-element.model';\\nimport { TreeOptions } from '../models/tree-options.model';\\nimport { ITreeOptions } from '../defs/api';\\nimport { TreeViewportComponent } from './tree-viewport.component';\\n\\n@Component({\\n  selector: 'Tree, tree-root',\\n  providers: [TreeModel],\\n  styles: [],\\n  template: `\\n      <tree-viewport #viewport>\\n          <div\\n                  class=\\\"angular-tree-component\\\"\\n                  [class.node-dragging]=\\\"treeDraggedElement.isDragging()\\\"\\n                  [class.angular-tree-component-rtl]=\\\"treeModel.options.rtl\\\">\\n              <tree-node-collection\\n                      *ngIf=\\\"treeModel.roots\\\"\\n                      [nodes]=\\\"treeModel.roots\\\"\\n                      [treeModel]=\\\"treeModel\\\"\\n                      [templates]=\\\"{\\n            loadingTemplate: loadingTemplate,\\n            treeNodeTemplate: treeNodeTemplate,\\n            treeNodeWrapperTemplate: treeNodeWrapperTemplate,\\n            treeNodeFullTemplate: treeNodeFullTemplate\\n          }\\\">\\n              </tree-node-collection>\\n              <tree-node-drop-slot\\n                      class=\\\"empty-tree-drop-slot\\\"\\n                      *ngIf=\\\"treeModel.isEmptyTree()\\\"\\n                      [dropIndex]=\\\"0\\\"\\n                      [node]=\\\"treeModel.virtualRoot\\\">\\n              </tree-node-drop-slot>\\n          </div>\\n      </tree-viewport>\\n  `\\n})\\nexport class TreeComponent implements OnChanges {\\n  _nodes: any[];\\n  _options: TreeOptions;\\n\\n  @ContentChild('loadingTemplate', { static: false }) loadingTemplate: TemplateRef<any>;\\n  @ContentChild('treeNodeTemplate', { static: false }) treeNodeTemplate: TemplateRef<any>;\\n  @ContentChild('treeNodeWrapperTemplate', { static: false }) treeNodeWrapperTemplate: TemplateRef<any>;\\n  @ContentChild('treeNodeFullTemplate', { static: false }) treeNodeFullTemplate: TemplateRef<any>;\\n  @ViewChild('viewport', { static: false }) viewportComponent: TreeViewportComponent;\\n\\n  // Will be handled in ngOnChanges\\n  @Input() set nodes(nodes: any[]) {\\n  };\\n\\n  @Input() set options(options: ITreeOptions) {\\n  };\\n\\n  @Input() set focused(value: boolean) {\\n    this.treeModel.setFocus(value);\\n  }\\n\\n  @Input() set state(state) {\\n    this.treeModel.setState(state);\\n  }\\n\\n  @Output() toggleExpanded;\\n  @Output() activate;\\n  @Output() deactivate;\\n  @Output() nodeActivate;\\n  @Output() nodeDeactivate;\\n  @Output() select;\\n  @Output() deselect;\\n  @Output() focus;\\n  @Output() blur;\\n  @Output() updateData;\\n  @Output() initialized;\\n  @Output() moveNode;\\n  @Output() copyNode;\\n  @Output() loadNodeChildren;\\n  @Output() changeFilter;\\n  @Output() event;\\n  @Output() stateChange;\\n\\n  constructor(\\n    public treeModel: TreeModel,\\n    public treeDraggedElement: TreeDraggedElement) {\\n\\n    treeModel.eventNames.forEach((name) => this[name] = new EventEmitter());\\n    treeModel.subscribeToState((state) => this.stateChange.emit(state));\\n  }\\n\\n  @HostListener('body: keydown', ['$event'])\\n  onKeydown($event) {\\n    if (!this.treeModel.isFocused) return;\\n    if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase())) return;\\n\\n    const focusedNode = this.treeModel.getFocusedNode();\\n\\n    this.treeModel.performKeyAction(focusedNode, $event);\\n  }\\n\\n  @HostListener('body: mousedown', ['$event'])\\n  onMousedown($event) {\\n    function isOutsideClick(startElement: Element, nodeName: string) {\\n      return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);\\n    }\\n\\n    if (isOutsideClick($event.target, 'tree-root')) {\\n      this.treeModel.setFocus(false);\\n    }\\n  }\\n\\n  ngOnChanges(changes) {\\n    if (changes.options || changes.nodes) {\\n      this.treeModel.setData({\\n        options: changes.options && changes.options.currentValue,\\n        nodes: changes.nodes && changes.nodes.currentValue,\\n        events: this.pick(this, this.treeModel.eventNames)\\n      });\\n    }\\n  }\\n\\n  sizeChanged() {\\n    this.viewportComponent.setViewport();\\n  }\\n\\n  private pick(object, keys) {\\n    return keys.reduce((obj, key) => {\\n      if (object && object.hasOwnProperty(key)) {\\n        obj[key] = object[key];\\n      }\\n      return obj;\\n    }, {});\\n  }\\n}\\n\",\"import { Directive, Input, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';\\n\\nconst EASE_ACCELERATION = 1.005;\\n\\n@Directive({\\n  selector: '[treeAnimateOpen]'\\n})\\nexport class TreeAnimateOpenDirective {\\n  private _isOpen: boolean;\\n\\n  @Input('treeAnimateOpenSpeed') animateSpeed: number;\\n  @Input('treeAnimateOpenAcceleration') animateAcceleration: number;\\n  @Input('treeAnimateOpenEnabled') isEnabled: boolean;\\n\\n  @Input('treeAnimateOpen')\\n  set isOpen(value: boolean) {\\n    if (value) {\\n      this._show();\\n      if (this.isEnabled && this._isOpen === false) {\\n        this._animateOpen();\\n      }\\n    } else {\\n      this.isEnabled ? this._animateClose() : this._hide();\\n    }\\n    this._isOpen = !!value;\\n  };\\n\\n  private innerElement: any;\\n\\n  constructor(\\n    private renderer: Renderer2,\\n    private templateRef: TemplateRef<any>,\\n    private viewContainerRef: ViewContainerRef) {\\n  }\\n\\n  private _show() {\\n    if (this.innerElement) return;\\n\\n    // create child view\\n    this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];\\n  }\\n\\n  private _hide() {\\n    this.viewContainerRef.clear();\\n    this.innerElement = null;\\n  }\\n\\n  private _animateOpen() {\\n    let delta = this.animateSpeed;\\n    let ease = this.animateAcceleration;\\n    let maxHeight = 0;\\n\\n    // set height to 0\\n    this.renderer.setStyle(this.innerElement, 'max-height', `0`);\\n\\n    // increase maxHeight until height doesn't change\\n    setTimeout(() => { // Allow inner element to create its content\\n      const i = setInterval(() => {\\n        if (!this._isOpen || !this.innerElement) return clearInterval(i);\\n\\n        maxHeight += delta;\\n        const roundedMaxHeight = Math.round(maxHeight);\\n\\n        this.renderer.setStyle(this.innerElement, 'max-height', `${roundedMaxHeight}px`);\\n        const height = this.innerElement.getBoundingClientRect ? this.innerElement.getBoundingClientRect().height : 0; // TBD use renderer\\n\\n        delta *= ease;\\n        ease *= EASE_ACCELERATION;\\n        if (height < roundedMaxHeight) {\\n          // Make maxHeight auto because animation finished and container might change height later on\\n          this.renderer.setStyle(this.innerElement, 'max-height', null);\\n          clearInterval(i);\\n        }\\n      }, 17);\\n    });\\n  }\\n\\n  private _animateClose() {\\n    if (!this.innerElement) return;\\n\\n    let delta = this.animateSpeed;\\n    let ease = this.animateAcceleration;\\n    let height = this.innerElement.getBoundingClientRect().height; // TBD use renderer\\n\\n    // slowly decrease maxHeight to 0, starting from current height\\n    const i = setInterval(() => {\\n      if (this._isOpen || !this.innerElement) return clearInterval(i);\\n\\n      height -= delta;\\n      this.renderer.setStyle(this.innerElement, 'max-height', `${height}px`);\\n      delta *= ease;\\n      ease *= EASE_ACCELERATION;\\n\\n      if (height <= 0) {\\n        // after animation complete - remove child element\\n        this.viewContainerRef.clear();\\n        this.innerElement = null;\\n        clearInterval(i);\\n      }\\n    }, 17);\\n  }\\n}\\n\",\"import { Component, Input, ViewEncapsulation } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'tree-node-children',\\n  encapsulation: ViewEncapsulation.None,\\n  styles: [],\\n  template: `\\n    <ng-container *treeMobxAutorun=\\\"{ dontDetach: true }\\\">\\n      <div\\n        [class.tree-children]=\\\"true\\\"\\n        [class.tree-children-no-padding]=\\\"node.options.levelPadding\\\"\\n        *treeAnimateOpen=\\\"\\n          node.isExpanded;\\n          speed: node.options.animateSpeed;\\n          acceleration: node.options.animateAcceleration;\\n          enabled: node.options.animateExpand\\n        \\\"\\n      >\\n        <tree-node-collection\\n          *ngIf=\\\"node.children\\\"\\n          [nodes]=\\\"node.children\\\"\\n          [templates]=\\\"templates\\\"\\n          [treeModel]=\\\"node.treeModel\\\"\\n        >\\n        </tree-node-collection>\\n        <tree-loading-component\\n          [style.padding-left]=\\\"node.getNodePadding()\\\"\\n          class=\\\"tree-node-loading\\\"\\n          *ngIf=\\\"!node.children\\\"\\n          [template]=\\\"templates.loadingTemplate\\\"\\n          [node]=\\\"node\\\"\\n        ></tree-loading-component>\\n      </div>\\n    </ng-container>\\n  `\\n})\\nexport class TreeNodeChildrenComponent {\\n  @Input() node: TreeNode;\\n  @Input() templates: any;\\n}\\n\",\"import { Component, Input, ViewEncapsulation, TemplateRef } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'tree-node-content',\\n  encapsulation: ViewEncapsulation.None,\\n  template: `\\n  <span *ngIf=\\\"!template\\\">{{ node.displayField }}</span>\\n  <ng-container\\n    [ngTemplateOutlet]=\\\"template\\\"\\n    [ngTemplateOutletContext]=\\\"{ $implicit: node, node: node, index: index }\\\">\\n  </ng-container>`,\\n})\\nexport class TreeNodeContent {\\n  @Input() node: TreeNode;\\n  @Input() index: number;\\n  @Input() template: TemplateRef<any>;\\n}\\n\",\"import { AfterViewInit, Directive, DoCheck, ElementRef, HostListener, Input, NgZone, OnDestroy, Renderer2 } from '@angular/core';\\nimport { TreeDraggedElement } from '../models/tree-dragged-element.model';\\n\\nconst DRAG_OVER_CLASS = 'is-dragging-over';\\n\\n@Directive({\\n  selector: '[treeDrag]'\\n})\\nexport class TreeDragDirective implements AfterViewInit, DoCheck, OnDestroy {\\n  @Input('treeDrag') draggedElement;\\n  @Input() treeDragEnabled;\\n  private readonly dragEventHandler: (ev: DragEvent) => void;\\n\\n  constructor(private el: ElementRef, private renderer: Renderer2, private treeDraggedElement: TreeDraggedElement, private ngZone: NgZone) {\\n    this.dragEventHandler = this.onDrag.bind(this);\\n  }\\n\\n  ngAfterViewInit() {\\n    let el: HTMLElement = this.el.nativeElement;\\n    this.ngZone.runOutsideAngular(() => {\\n      el.addEventListener('drag', this.dragEventHandler);\\n    });\\n  }\\n\\n  ngDoCheck() {\\n    this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\\n  }\\n\\n  ngOnDestroy() {\\n    let el: HTMLElement = this.el.nativeElement;\\n    el.removeEventListener('drag', this.dragEventHandler);\\n  }\\n\\n  @HostListener('dragstart', ['$event']) onDragStart(ev) {\\n    // setting the data is required by firefox\\n    ev.dataTransfer.setData('text', ev.target.id);\\n    this.treeDraggedElement.set(this.draggedElement);\\n    if (this.draggedElement.mouseAction) {\\n      this.draggedElement.mouseAction('dragStart', ev);\\n    }\\n  }\\n\\n  onDrag(ev) {\\n    if (this.draggedElement.mouseAction) {\\n      this.draggedElement.mouseAction('drag', ev);\\n    }\\n  }\\n\\n  @HostListener('dragend') onDragEnd() {\\n    if (this.draggedElement.mouseAction) {\\n      this.draggedElement.mouseAction('dragEnd');\\n    }\\n    this.treeDraggedElement.set(null);\\n  }\\n}\\n\",\"import { Component, Input, ViewEncapsulation } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'tree-node-expander',\\n  encapsulation: ViewEncapsulation.None,\\n  styles: [],\\n  template: `\\n    <ng-container *treeMobxAutorun=\\\"{ dontDetach: true }\\\">\\n      <span\\n        *ngIf=\\\"node.hasChildren\\\"\\n        [class.toggle-children-wrapper-expanded]=\\\"node.isExpanded\\\"\\n        [class.toggle-children-wrapper-collapsed]=\\\"node.isCollapsed\\\"\\n        class=\\\"toggle-children-wrapper\\\"\\n        (click)=\\\"node.mouseAction('expanderClick', $event)\\\"\\n      >\\n        <span class=\\\"toggle-children\\\"></span>\\n      </span>\\n      <span *ngIf=\\\"!node.hasChildren\\\" class=\\\"toggle-children-placeholder\\\">\\n      </span>\\n    </ng-container>\\n  `\\n})\\nexport class TreeNodeExpanderComponent {\\n  @Input() node: TreeNode;\\n}\\n\",\"import { Component, Input, ViewEncapsulation } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'tree-node-checkbox',\\n  encapsulation: ViewEncapsulation.None,\\n  styles: [],\\n  template: `\\n    <ng-container *treeMobxAutorun=\\\"{ dontDetach: true }\\\">\\n      <input\\n        class=\\\"tree-node-checkbox\\\"\\n        type=\\\"checkbox\\\"\\n        (click)=\\\"node.mouseAction('checkboxClick', $event)\\\"\\n        [checked]=\\\"node.isSelected\\\"\\n        [indeterminate]=\\\"node.isPartiallySelected\\\"\\n      />\\n    </ng-container>\\n  `\\n})\\nexport class TreeNodeCheckboxComponent {\\n  @Input() node: TreeNode;\\n}\\n\",\"import { Component , Input , ViewEncapsulation } from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'tree-node-wrapper' ,\\n  encapsulation: ViewEncapsulation.None ,\\n  styles: [] ,\\n  template: `\\n      <div *ngIf=\\\"!templates.treeNodeWrapperTemplate\\\" class=\\\"node-wrapper\\\" [style.padding-left]=\\\"node.getNodePadding()\\\">\\n          <tree-node-checkbox *ngIf=\\\"node.options.useCheckbox\\\" [node]=\\\"node\\\"></tree-node-checkbox>\\n          <tree-node-expander [node]=\\\"node\\\"></tree-node-expander>\\n          <div class=\\\"node-content-wrapper\\\"\\n               [class.node-content-wrapper-active]=\\\"node.isActive\\\"\\n               [class.node-content-wrapper-focused]=\\\"node.isFocused\\\"\\n               (click)=\\\"node.mouseAction('click', $event)\\\"\\n               (dblclick)=\\\"node.mouseAction('dblClick', $event)\\\"\\n               (mouseover)=\\\"node.mouseAction('mouseOver', $event)\\\"\\n               (mouseout)=\\\"node.mouseAction('mouseOut', $event)\\\"\\n               (contextmenu)=\\\"node.mouseAction('contextMenu', $event)\\\"\\n               (treeDrop)=\\\"node.onDrop($event)\\\"\\n               (treeDropDragOver)=\\\"node.mouseAction('dragOver', $event)\\\"\\n               (treeDropDragLeave)=\\\"node.mouseAction('dragLeave', $event)\\\"\\n               (treeDropDragEnter)=\\\"node.mouseAction('dragEnter', $event)\\\"\\n               [treeAllowDrop]=\\\"node.allowDrop\\\"\\n               [allowDragoverStyling]=\\\"node.allowDragoverStyling()\\\"\\n               [treeDrag]=\\\"node\\\"\\n               [treeDragEnabled]=\\\"node.allowDrag()\\\">\\n\\n              <tree-node-content [node]=\\\"node\\\" [index]=\\\"index\\\" [template]=\\\"templates.treeNodeTemplate\\\">\\n              </tree-node-content>\\n          </div>\\n      </div>\\n      <ng-container\\n              [ngTemplateOutlet]=\\\"templates.treeNodeWrapperTemplate\\\"\\n              [ngTemplateOutletContext]=\\\"{ $implicit: node, node: node, index: index, templates: templates }\\\">\\n      </ng-container>\\n  `\\n})\\n\\nexport class TreeNodeWrapperComponent {\\n\\n  @Input() node: TreeNode;\\n  @Input() index: number;\\n  @Input() templates: any;\\n\\n}\\n\",\"import {\\n  Component,\\n  Input,\\n  ViewEncapsulation,\\n} from '@angular/core';\\nimport { TreeNode } from '../models/tree-node.model';\\n\\n@Component({\\n  selector: 'TreeNode, tree-node',\\n  encapsulation: ViewEncapsulation.None,\\n  styles: [],\\n  template: `\\n    <ng-container *treeMobxAutorun=\\\"{ dontDetach: true }\\\">\\n      <div\\n        *ngIf=\\\"!templates.treeNodeFullTemplate\\\"\\n        [class]=\\\"node.getClass()\\\"\\n        [class.tree-node]=\\\"true\\\"\\n        [class.tree-node-expanded]=\\\"node.isExpanded && node.hasChildren\\\"\\n        [class.tree-node-collapsed]=\\\"node.isCollapsed && node.hasChildren\\\"\\n        [class.tree-node-leaf]=\\\"node.isLeaf\\\"\\n        [class.tree-node-active]=\\\"node.isActive\\\"\\n        [class.tree-node-focused]=\\\"node.isFocused\\\"\\n      >\\n        <tree-node-drop-slot\\n          *ngIf=\\\"index === 0\\\"\\n          [dropIndex]=\\\"node.index\\\"\\n          [node]=\\\"node.parent\\\"\\n        ></tree-node-drop-slot>\\n\\n        <tree-node-wrapper\\n          [node]=\\\"node\\\"\\n          [index]=\\\"index\\\"\\n          [templates]=\\\"templates\\\"\\n        ></tree-node-wrapper>\\n\\n        <tree-node-children\\n          [node]=\\\"node\\\"\\n          [templates]=\\\"templates\\\"\\n        ></tree-node-children>\\n        <tree-node-drop-slot\\n          [dropIndex]=\\\"node.index + 1\\\"\\n          [node]=\\\"node.parent\\\"\\n        ></tree-node-drop-slot>\\n      </div>\\n      <ng-container\\n        [ngTemplateOutlet]=\\\"templates.treeNodeFullTemplate\\\"\\n        [ngTemplateOutletContext]=\\\"{\\n          $implicit: node,\\n          node: node,\\n          index: index,\\n          templates: templates\\n        }\\\"\\n      >\\n      </ng-container>\\n    </ng-container>\\n  `\\n})\\nexport class TreeNodeComponent {\\n  @Input() node: TreeNode;\\n  @Input() index: number;\\n  @Input() templates: any;\\n}\\n\",\"import { NgModule } from '@angular/core';\\nimport { CommonModule } from '@angular/common';\\nimport { TreeMobxAutorunDirective } from './mobx-angular/tree-mobx-autorun.directive';\\n\\nimport {\\n  IActionHandler,\\n  IActionMapping,\\n  TREE_ACTIONS\\n} from './models/tree-options.model';\\nimport {\\n  IAllowDragFn,\\n  IAllowDropFn,\\n  ITreeOptions,\\n  ITreeState\\n} from './defs/api';\\nimport { KEYS } from './constants/keys';\\nimport { TreeModel } from './models/tree.model';\\nimport { TreeNode } from './models/tree-node.model';\\nimport { TreeDraggedElement } from './models/tree-dragged-element.model';\\nimport { TreeVirtualScroll } from './models/tree-virtual-scroll.model';\\nimport { LoadingComponent } from './components/loading.component';\\nimport { TreeComponent } from './components/tree.component';\\nimport { TreeNodeComponent } from './components/tree-node.component';\\nimport { TreeNodeContent } from './components/tree-node-content.component';\\nimport { TreeNodeDropSlot } from './components/tree-node-drop-slot.component';\\nimport { TreeNodeExpanderComponent } from './components/tree-node-expander.component';\\nimport { TreeNodeChildrenComponent } from './components/tree-node-children.component';\\nimport { TreeNodeCollectionComponent } from './components/tree-node-collection.component';\\nimport { TreeNodeWrapperComponent } from './components/tree-node-wrapper.component';\\nimport { TreeViewportComponent } from './components/tree-viewport.component';\\nimport { TreeNodeCheckboxComponent } from './components/tree-node-checkbox.component';\\nimport { TreeDropDirective } from './directives/tree-drop.directive';\\nimport { TreeDragDirective } from './directives/tree-drag.directive';\\nimport { TreeAnimateOpenDirective } from './directives/tree-animate-open.directive';\\n\\n@NgModule({\\n  declarations: [\\n    TreeComponent,\\n    TreeNodeComponent,\\n    TreeNodeContent,\\n    LoadingComponent,\\n    TreeDropDirective,\\n    TreeDragDirective,\\n    TreeNodeExpanderComponent,\\n    TreeNodeChildrenComponent,\\n    TreeNodeDropSlot,\\n    TreeNodeCollectionComponent,\\n    TreeViewportComponent,\\n    TreeNodeWrapperComponent,\\n    TreeNodeCheckboxComponent,\\n    TreeAnimateOpenDirective,\\n    TreeMobxAutorunDirective\\n  ],\\n  exports: [\\n    TreeComponent,\\n    TreeNodeComponent,\\n    TreeNodeContent,\\n    LoadingComponent,\\n    TreeDropDirective,\\n    TreeDragDirective,\\n    TreeNodeExpanderComponent,\\n    TreeNodeChildrenComponent,\\n    TreeNodeDropSlot,\\n    TreeNodeCollectionComponent,\\n    TreeViewportComponent,\\n    TreeNodeWrapperComponent,\\n    TreeNodeCheckboxComponent,\\n    TreeAnimateOpenDirective,\\n    TreeMobxAutorunDirective\\n  ],\\n  imports: [CommonModule],\\n  providers: []\\n})\\nexport class TreeModule {}\\n\\nexport {\\n  TreeModel,\\n  TreeNode,\\n  TreeDraggedElement,\\n  TreeVirtualScroll,\\n  ITreeOptions,\\n  TREE_ACTIONS,\\n  KEYS,\\n  IActionMapping,\\n  IActionHandler,\\n  IAllowDropFn,\\n  IAllowDragFn,\\n  LoadingComponent,\\n  TreeAnimateOpenDirective,\\n  TreeComponent,\\n  TreeNodeComponent,\\n  TreeNodeWrapperComponent,\\n  TreeNodeContent,\\n  TreeDropDirective,\\n  TreeDragDirective,\\n  TreeNodeExpanderComponent,\\n  TreeNodeChildrenComponent,\\n  TreeNodeDropSlot,\\n  TreeNodeCollectionComponent,\\n  TreeViewportComponent,\\n  TreeNodeCheckboxComponent,\\n  ITreeState\\n};\\n\",\"/*\\n * Public API Surface of angular-tree-component\\n */\\n\\nexport * from './lib/angular-tree-component.module';\\nexport * from './lib/mobx-angular/tree-mobx-autorun.directive';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[\"__decorate\",\"computed\",\"observable\",\"action\",\"i1.TreeModel\",\"_c0\",\"i1.TreeVirtualScroll\",\"_c1\",\"DRAG_OVER_CLASS\",\"i1.TreeDraggedElement\",\"mobxAction\",\"mobxComputed\",\"mobxObservable\",\"i2.TreeDraggedElement\"],\"mappings\":\"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\"}","type":"asset"}]}